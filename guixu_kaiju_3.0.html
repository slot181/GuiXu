```
<!DOCTYPE html>
<!-- 类脑/旅程梦星作品，禁止二传，禁止商业化，均无偿免费开源分享 -->
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>归墟 - 【梦星献作】</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
      /* 类脑/旅程梦星作品，禁止二传，禁止商业化，均无偿免费开源分享 (V13 - Final Fix) */
      @import url('https://fonts.googleapis.com/css2?family=ZCOOL+KuaiLe&family=Ma+Shan+Zheng&display=swap');

      :root {
          --color-primary: #c9aa71;
          --color-primary-hover: #daa520;
          --color-text-light: #e0dcd1;
          --color-text-medium: #ccc;
          --color-text-dark: #8b7355;
          --color-bg-dark: #0a0a14;
          --color-bg-panel: rgba(15, 15, 35, 0.7);
          --color-border: rgba(201, 170, 113, 0.5);
          --bg-overlay-color: rgba(0, 0, 0, 0.5);
          --bg-backdrop-filter: blur(0px);
      }

      body,
      html {
        margin: 0;
        padding: 0;
        width: 100%;
      }

      #startup-page {
        min-height: 100vh;
        width: 100%;
        height: auto;
        color: white;
        font-family: 'ZCOOL+KuaiLe', 'Ma+Shan+Zheng', serif;
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        background-attachment: fixed;
        transition: background-image 1s ease-in-out, background-color 0.5s ease;
        display: flex;
        flex-direction: column;
        align-items: center;
        position: relative;
      }
      
      #startup-page::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: var(--bg-overlay-color);
        backdrop-filter: var(--bg-backdrop-filter);
        -webkit-backdrop-filter: var(--bg-backdrop-filter);
        z-index: 1;
        transition: background 0.5s ease, backdrop-filter 0.5s ease;
      }

      .content-wrapper {
        position: relative;
        z-index: 2;
        text-align: center;
        padding: 20px;
        width: 100%;
        max-width: 800px;
        max-height: 90vh;
        overflow-y: auto;
        box-sizing: border-box;
      }
      
      .loading-placeholder { text-align: center; padding: 40px 20px; color: #c9aa71; font-style: italic; }
      .title { font-size: clamp(2.5rem, 6vw, 4rem); color: #c9aa71; text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.7); margin-bottom: 20px; }

      .credits-container { margin-bottom: 30px; padding: 0 20px; font-size: 0.9rem; color: #ccc; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7); }
      .credits-author { font-size: 1rem; color: #c9aa71; margin-bottom: 15px; }
      .credits-musings, .credits-musings1, .credits-musings2, .credits-musings4, .credits-musings5 { margin-bottom: 8px; line-height: 1.5; }
      .credits-musings1 { color: #ffdddd; }
      .credits-grateful { color: #ffd700; }
      .credits-journey { color: #add8e6; }
      .credits-apology { color: #e0b4b4; }
      .credits-proud { color: #90ee90; font-weight: bold; }
      .credits-final-thanks { color: #ffc0cb; }
      .credits-info { color: #b0c4de; }
      .credits-warning { color: #ff6347; font-style: italic; }

      #main-menu-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 15px;
        margin: 40px auto;
        width: 100%;
        max-width: 280px;
      }

      .main-menu-btn {
        font-family: inherit;
        font-size: 1.5rem;
        padding: 15px 0;
        width: 100%;
        background: linear-gradient(45deg, #8b4513, #cd853f);
        border: 2px solid #daa520;
        color: #fff;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.3s ease;
        text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5);
        text-align: center;
        box-sizing: border-box;
      }
      .main-menu-btn:hover { background: linear-gradient(45deg, #cd853f, #daa520); transform: scale(1.05); }
      
      #about-guixu-btn {
        position: fixed;
        bottom: 15px;
        right: 15px;
        z-index: 998;
        padding: 8px 15px;
        font-size: 1rem;
        font-family: inherit;
        background: linear-gradient(45deg, #8b4513, #cd853f);
        border: 2px solid #daa520;
        color: #fff;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.3s ease;
        text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5);
      }
      #about-guixu-btn:hover { background: linear-gradient(45deg, #cd853f, #daa520); transform: scale(1.05); }

      .generate-btn {
        font-family: inherit;
        font-size: 1.5rem;
        padding: 15px 40px;
        background: linear-gradient(45deg, #8b4513, #cd853f);
        border: 2px solid #daa520;
        color: #fff;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.3s ease;
        text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5);
      }
      .generate-btn:hover { background: linear-gradient(45deg, #cd853f, #daa520); transform: scale(1.05); }

      #setup-form { display: none; flex-direction: column; gap: 20px; width: 100%; }
      .form-section { background: rgba(15, 15, 35, 0.7); border: 1px solid rgba(201, 170, 113, 0.5); border-radius: 8px; padding: 20px; margin-bottom: 20px; }
      .form-section label, #points-tracker { display: block; font-size: 1.2rem; color: #c9aa71; margin-bottom: 10px; text-align: left; }
      #points-tracker { text-align: center; font-size: 1.5rem; margin-bottom: 20px; text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5); }
      .difficulty-selection, .attributes-grid, .talent-selection { display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 20px; width: 100%; }
      .difficulty-card, .attribute-card { background: rgba(15, 15, 35, 0.8); border: 1px solid rgba(201, 170, 113, 0.6); border-radius: 8px; padding: 20px; cursor: pointer; transition: all 0.3s ease; text-align: left; }
      .difficulty-card:hover, .attribute-card:hover { transform: translateY(-5px); box-shadow: 0 5px 15px rgba(201, 170, 113, 0.2); }
      .difficulty-card.selected { border-color: #daa520; background: rgba(201, 170, 113, 0.2); }
      .difficulty-header, .attribute-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
      .difficulty-name, .attribute-name { font-size: 1.3rem; color: #c9aa71; font-weight: bold; }
      .points-value { font-size: 1.2rem; color: #fff; background: #8b4513; padding: 5px 10px; border-radius: 5px; }
      .attribute-value { display: flex; align-items: center; gap: 10px; }
      .value-btn { width: 30px; height: 30px; border: 1px solid #daa520; border-radius: 50%; background: rgba(139, 69, 19, 0.5); color: white; cursor: pointer; font-size: 1.5rem; line-height: 1; display: flex; align-items: center; justify-content: center; transition: all 0.3s ease; }
      .value-btn:hover:not(:disabled) { background: #cd853f; }
      .value-btn:disabled { background: #5a5a5a; cursor: not-allowed; border-color: #777; }
      .value, .value-input { font-size: 1.2rem; font-weight: bold; min-width: 40px; max-width: 60px; text-align: center; background: transparent; color: white; border: none; font-family: inherit; }
      .value-input:focus { outline: 1px solid #c9aa71; background: rgba(0, 0, 0, 0.2); }
      .value-input::-webkit-outer-spin-button, .value-input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
      .value-input[type='number'] { -moz-appearance: textfield; }
      .talent-card, .background-card, .gender-card { background: rgba(15, 15, 35, 0.8); border: 1px solid rgba(201, 170, 113, 0.6); border-radius: 8px; padding: 15px; cursor: pointer; transition: all 0.3s ease; margin-bottom: 10px; }
      .talent-card:hover, .background-card:hover, .gender-card:hover { transform: translateY(-5px); box-shadow: 0 5px 15px rgba(201, 170, 113, 0.2); }
      .talent-card.selected, .background-card.selected, .gender-card.selected { border-color: #daa520; background: rgba(201, 170, 113, 0.2); }
      .talent-card.disabled, .editor-item.disabled { opacity: 0.5; cursor: not-allowed; background: #333; }
      .talent-card.required { border-color: #ff6b6b; cursor: not-allowed; }
      .talent-card.required:hover { transform: none; box-shadow: none; }
      .talent-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
      .talent-name { font-size: 1.2rem; color: #c9aa71; font-weight: bold; }
      .talent-description { font-size: 0.9rem; color: #ccc; margin: 0; }
      .custom-talent-input { width: 100%; min-height: 60px; background: rgba(0, 0, 0, 0.5); border: 1px solid #8b7355; border-radius: 4px; color: #e0dcd1; padding: 10px; font-size: 1rem; font-family: inherit; resize: vertical; box-sizing: border-box; }
      .loading-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); z-index: 10000; justify-content: center; align-items: center; font-size: 1.5rem; color: #c9aa71; }
      .attribute-card { position: relative; }
      .attribute-tooltip { position: absolute; top: -10px; left: 50%; transform: translateX(-50%) translateY(-100%); background: rgba(0, 0, 0, 0.9); color: #fff; padding: 8px 12px; border-radius: 6px; font-size: 0.85rem; white-space: nowrap; z-index: 1000; opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease; border: 1px solid #c9aa71; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3); max-width: 300px; white-space: normal; line-height: 1.4; }
      .attribute-tooltip::after { content: ''; position: absolute; top: 100%; left: 50%; transform: translateX(-50%); border: 6px solid transparent; border-top-color: rgba(0, 0, 0, 0.9); }
      .attribute-card:hover .attribute-tooltip { opacity: 1; visibility: visible; }
      .d-flex { display: flex; }
      .flex-column { flex-direction: column; }
      .align-items-center { align-items: center; }
      .justify-content-between { justify-content: space-between; }
      .gap-2 { gap: 2px; }
      .gap-5 { gap: 5px; }
      .panel-section { margin-bottom: 15px; padding: 8px; background: rgba(15, 15, 35, 0.7); border-radius: 8px; border: 1px solid rgba(201, 170, 113, 0.3); }
      .section-title { font-size: 13px; color: #c9aa71; margin-bottom: 8px; text-align: center; border-bottom: 1px solid rgba(201, 170, 113, 0.3); padding-bottom: 4px; }
      .auto-write-label { font-size: 12px; color: #8b7355; cursor: pointer; }
      .index-stepper-btn { font-family: inherit; background: transparent; border: 1px solid var(--color-text-dark); color: var(--color-primary); width: 22px; height: 15px; padding: 0; font-size: 10px; line-height: 15px; text-align: center; border-radius: 3px; cursor: pointer; transition: all 0.2s ease; }
      .index-stepper-btn:hover { background: rgba(201, 170, 113, 0.2); border-color: var(--color-primary); }
      .index-stepper-btn:disabled { opacity: 0.4; cursor: not-allowed; background: #333; }
      .editor-list-container { max-height: 400px; overflow-y: auto; border: 1px solid #8b7355; padding: 10px; border-radius: 4px; background: rgba(0, 0, 0, 0.2); }
      .editor-item { background: rgba(15, 15, 35, 0.7); border: 1px solid rgba(201, 170, 113, 0.5); border-radius: 6px; padding: 15px; margin-bottom: 10px; }
      .item-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; color: #c9aa71; flex-wrap: wrap; gap: 5px 15px; }
      .item-description { font-size: 0.9rem; color: #ccc; margin-bottom: 10px; white-space: pre-wrap; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; }
      .item-actions { text-align: right; }
      .editor-modal { display: none; position: fixed; z-index: 1001; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0, 0, 0, 0.7); justify-content: center; align-items: center; }
      .modal-content { background: rgba(15, 15, 35, 0.95); margin: auto; padding: 30px; border: 1px solid #c9aa71; border-radius: 10px; width: 90%; max-width: 600px; color: #e0dcd1; box-sizing: border-box; max-height: 90vh; display: flex; flex-direction: column; }
      .modal-content form { overflow-y: auto; padding-right: 15px; }
      .modal-content h2 { color: #c9aa71; text-align: center; margin-bottom: 25px; flex-shrink: 0; }
      .modal-form-group { margin-bottom: 20px; }
      .modal-form-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 15px; }
      .modal-form-group label { display: block; margin-bottom: 8px; color: #c9aa71; font-size: 1rem; }
      .modal-input, .modal-textarea, .modal-select { width: 100%; background: rgba(0, 0, 0, 0.5); border: 1px solid #8b7355; border-radius: 4px; color: #e0dcd1; padding: 12px; font-size: 1rem; font-family: inherit; box-sizing: border-box; }
      .modal-select { appearance: none; background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3e%3cpath fill='none' stroke='%23c9aa71' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M2 5l6 6 6-6'/%3e%3c/svg%3e"); background-repeat: no-repeat; background-position: right 0.7rem center; background-size: 1em; }
      .modal-textarea { resize: vertical; min-height: 100px; }
      .modal-actions { text-align: right; margin-top: 30px; flex-shrink: 0; }
      .editor-btn, .tab-button, .theme-btn, .wb-filter-btn { font-family: inherit; font-size: 1rem; padding: 10px 20px; background: transparent; border: 1px solid #c9aa71; color: #c9aa71; border-radius: 5px; cursor: pointer; transition: all 0.3s ease; margin-left: 10px; }
      .editor-btn:hover, .tab-button:hover, .tab-button.active, .theme-btn:hover, .wb-filter-btn:hover, .wb-filter-btn.active { background: rgba(201, 170, 113, 0.2); box-shadow: 0 0 10px rgba(201, 170, 113, 0.3); }
      .editor-btn.btn-danger, .theme-btn.theme-btn-red { border-color: #ff6347; color: #ff6347; }
      .editor-btn.btn-danger:hover, .theme-btn.theme-btn-red:hover { background: rgba(255, 99, 71, 0.2); }
      .editor-btn.btn-primary, .theme-btn.theme-btn-gold { background: linear-gradient(45deg, #8b4513, #cd853f); color: #fff; border-color: #daa520; }
      .editor-btn.btn-primary:hover, .theme-btn.theme-btn-gold:hover { background: linear-gradient(45deg, #cd853f, #daa520); }
      .theme-btn.btn-small { padding: 4px 10px; font-size: 0.9rem; }
      @keyframes fadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }
      .item-actions .editor-btn { padding: 5px 10px; font-size: 0.9rem; }
      .preset-editor-layout { display: flex; gap: 20px; }
      .preset-list-panel { flex: 1; max-width: 300px; }
      .preset-details-panel { flex: 2; padding: 20px; background: rgba(20, 20, 40, 0.8); border-radius: 8px; margin-left: 20px; max-height: 80vh; overflow-y: auto; }
      .preset-header { margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid rgba(201, 170, 113, 0.3); }
      .preset-controls { display: flex; gap: 15px; align-items: center; margin-bottom: 20px; padding: 10px; background: rgba(0, 0, 0, 0.2); border-radius: 6px; }
      .preset-controls .editor-btn { margin-left: 0; padding: 5px 12px; font-size: 0.9rem; }
      .preset-toggle-icon-btn { background: transparent; border: none; color: #c9aa71; cursor: pointer; padding: 5px; border-radius: 50%; display: flex; align-items: center; justify-content: center; transition: background-color 0.3s ease; }
      .preset-toggle-icon-btn:hover { background-color: rgba(201, 170, 113, 0.2); }
      .preset-toggle-icon-btn svg { transition: transform 0.3s ease; stroke: #c9aa71; }
      .preset-toggle-icon-btn.collapsed svg { transform: rotate(-180deg); }
      .preset-basic-info { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
      .preset-tabs { display: flex; border-bottom: 2px solid rgba(201, 170, 113, 0.3); margin-bottom: 20px; }
      .preset-tab-btn { background: transparent; border: none; color: #ccc; padding: 12px 20px; cursor: pointer; border-bottom: 2px solid transparent; transition: all 0.3s ease; font-size: 14px; }
      .preset-tab-btn:hover { color: #c9aa71; background: rgba(201, 170, 113, 0.1); }
      .preset-tab-btn.active { color: #c9aa71; border-bottom-color: #c9aa71; background: rgba(201, 170, 113, 0.1); }
      .preset-tab-content { display: none; min-height: 300px; }
      .preset-tab-content.active { display: block; }
      .preset-actions { display: flex; gap: 10px; margin-top: 15px; }
      .preset-actions .editor-btn { flex: 1; padding: 8px 12px; font-size: 12px; margin-left: 0; }
      .preset-actions-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; padding: 20px; }
      .action-btn { padding: 15px 20px; background: linear-gradient(45deg, #8b4513, #cd853f); border: 2px solid #daa520; color: #fff; border-radius: 8px; cursor: pointer; transition: all 0.3s ease; font-size: 14px; text-align: center; }
      .action-btn:hover { background: linear-gradient(45deg, #cd853f, #daa520); transform: scale(1.02); }
      .action-btn.btn-danger { background: linear-gradient(45deg, #8b0000, #dc143c); border-color: #ff6347; }
      .action-btn.btn-danger:hover { background: linear-gradient(45deg, #dc143c, #ff6347); }
      .series-section { padding: 20px; background: rgba(15, 15, 35, 0.6); border-radius: 8px; border: 1px solid rgba(201, 170, 113, 0.3); }
      .series-section h4 { color: #c9aa71; margin-bottom: 15px; text-align: center; }
      .series-talents, .series-backgrounds, .series-extensions { margin-bottom: 20px; }
      .series-talents h5, .series-backgrounds h5, .series-extensions h5 { color: #ddd; margin-bottom: 10px; padding-bottom: 5px; border-bottom: 1px solid rgba(201, 170, 113, 0.2); }
      .series-items { display: grid; gap: 8px; }
      .series-item { display: flex; align-items: center; justify-content: space-between; padding: 8px 12px; background: rgba(20, 20, 40, 0.6); border-radius: 4px; border-left: 3px solid transparent; flex-wrap: wrap; gap: 10px; cursor: pointer; transition: background-color 0.3s ease; }
      .series-item.required { border-left-color: #ff6b6b; }
      .series-item.optional { border-left-color: #4ecdc4; }
      .series-item.exclusive { border-left-color: #ffd700; background: rgba(255, 215, 0, 0.1); }
      .item-name { font-weight: bold; color: #fff; flex-grow: 1; }
      .item-cost { color: #c9aa71; font-size: 12px; flex-shrink: 0; }
      .item-author { color: #888; font-size: 11px; flex-shrink: 0; }
      .tag { padding: 2px 6px; border-radius: 3px; font-size: 10px; font-weight: bold; flex-shrink: 0; }
      .required-tag { background: #ff6b6b; color: white; }
      .optional-tag { background: #4ecdc4; color: white; }
      .exclusive-tag { background: #ffd700; color: #333; }
      .series-item:hover { background-color: rgba(201, 170, 113, 0.1); }
      .item-description-details { display: none; flex-basis: 100%; padding: 10px; margin-top: 10px; background: rgba(0, 0, 0, 0.3); border-radius: 4px; font-size: 0.9rem; color: #ccc; white-space: pre-wrap; overflow-wrap: break-word; word-break: break-all; min-width: 0; border-left: 2px solid #8b7355; padding-left: 15px; }
      .series-actions { display: flex; gap: 10px; justify-content: center; margin-top: 20px; }
      .preset-selection-list { max-height: 300px; overflow-y: auto; border: 1px solid #8b7355; padding: 10px; border-radius: 4px; background: rgba(0, 0, 0, 0.2); }
      .preset-list-item { padding: 10px; border-bottom: 1px solid #8b7355; cursor: pointer; transition: background-color 0.3s; }
      .preset-list-item:hover, .preset-list-item.selected { background-color: rgba(201, 170, 113, 0.2); }
      .talent-selection-container { display: flex; gap: 20px; margin-top: 15px; }
      .talent-selection-box { flex: 1; border: 1px solid #8b7355; padding: 10px; border-radius: 4px; max-height: 250px; overflow-y: auto; }
      .talent-selection-box h4 { margin-top: 0; color: #c9aa71; }
      .selected-talent-item { display: flex; justify-content: space-between; align-items: center; padding: 5px 10px !important; margin-bottom: 5px; flex-wrap: wrap; gap: 10px; background: rgba(15, 15, 35, 0.7); border: 1px solid rgba(201, 170, 113, 0.5); border-radius: 6px; }
      .selected-talent-name { flex-grow: 1; }
      .talent-preset-actions { display: flex; align-items: center; gap: 8px; flex-shrink: 0; }
      .talent-preset-actions .tag { margin-right: 5px; }
      .talent-preset-actions button { padding: 2px 6px; font-size: 10px; background: transparent; border: 1px solid #8b7355; color: #c9aa71; border-radius: 3px; cursor: pointer; white-space: nowrap; }
      .talent-preset-actions button:hover { background: rgba(201, 170, 113, 0.2); }
      .wb-filter-controls { display: flex; flex-direction: column; gap: 15px; margin-bottom: 15px; }
      .wb-filter-buttons { display: flex; justify-content: center; gap: 10px; flex-wrap: wrap; }
      .wb-search-controls { display: flex; justify-content: center; gap: 10px; align-items: center; }
      #wb-search-input { width: 100%; max-width: 300px; padding: 8px 12px; font-size: 0.9rem; }
      #wb-refresh-btn { padding: 8px 15px; font-size: 0.9rem; margin-left: 0; flex-shrink: 0; }
      .wb-filter-btn { padding: 5px 15px; font-size: 0.9rem; margin: 0; }
      .wb-item-header { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px; margin-bottom: 10px; }
      .wb-item-title { display: flex; align-items: center; gap: 8px; color: #c9aa71; font-weight: bold; flex-grow: 1; }
      .wb-item-indicators { display: flex; align-items: center; gap: 15px; font-size: 0.8rem; color: #ccc; }
      .strategy-indicator { width: 12px; height: 12px; border-radius: 50%; display: inline-block; flex-shrink: 0; box-shadow: 0 0 5px currentColor; }
      .strategy-indicator.constant { color: #57a2f2; background-color: #57a2f2; }
      .strategy-indicator.selective { color: #57f287; background-color: #57f287; }
      .status-indicator { width: 12px; height: 12px; border-radius: 50%; display: inline-block; flex-shrink: 0; }
      .status-indicator.enabled { background-color: #57F287; box-shadow: 0 0 5px #57F287; }
      .status-indicator.disabled { background-color: #5a5a5a; }
      #wb-strategy-toggle-btn.strategy-constant { border-color: #57a2f2; color: #57a2f2; }
      #wb-strategy-toggle-btn.strategy-constant:hover { background: rgba(87, 162, 242, 0.2); }
      #wb-strategy-toggle-btn.strategy-selective { border-color: #57f287; color: #57f287; }
      #wb-strategy-toggle-btn.strategy-selective:hover { background: rgba(87, 242, 135, 0.2); }
      #startup-choice-container { display: none; width: 100%; max-width: 1200px; }
      .startup-choice-layout { display: flex; gap: 30px; width: 100%; }
      .choice-column { flex: 1; background: rgba(15, 15, 35, 0.7); border: 1px solid rgba(201, 170, 113, 0.5); border-radius: 8px; padding: 20px; }
      .choice-column h2 { color: #c9aa71; text-align: center; border-bottom: 1px solid rgba(201, 170, 113, 0.3); padding-bottom: 10px; margin-top: 0; }
      .choice-list { max-height: 400px; overflow-y: auto; }
      .choice-item { background: rgba(15, 15, 35, 0.8); border: 1px solid rgba(201, 170, 113, 0.6); border-radius: 8px; padding: 15px; cursor: pointer; transition: all 0.3s ease; margin-bottom: 10px; text-align: left; }
      .choice-item:hover { transform: translateY(-5px); box-shadow: 0 5px 15px rgba(201, 170, 113, 0.2); border-color: #daa520; }
      .choice-item-title { font-size: 1.2rem; color: #c9aa71; font-weight: bold; }
      .choice-item-desc { font-size: 0.9rem; color: #ccc; margin-top: 5px; }
      #preset-back-to-list-btn { display: none; margin-bottom: 20px; background: transparent; border: 1px solid #c9aa71; color: #c9aa71; padding: 10px 15px; border-radius: 5px; cursor: pointer; font-size: 1rem; width: 100%; box-sizing: border-box; }
      .modal-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); justify-content: center; align-items: center; z-index: 1000; }
      #save-load-modal .modal-content, #default-import-modal .modal-content, #settings-modal .modal-content { background: rgba(15, 15, 35, 0.95); border: 1px solid var(--color-primary); border-radius: 8px; padding: 20px; width: 90%; max-width: 800px; display: flex; flex-direction: column; box-shadow: 0 0 20px rgba(201, 170, 113, 0.3); max-height: 80vh; }
      #settings-modal .modal-content { max-height: none; height: auto; max-width: 500px; }
      .modal-header { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid var(--color-border); padding-bottom: 10px; margin-bottom: 15px; gap: 15px; }
      .modal-header-actions { margin-left: auto; display: flex; gap: 10px; align-items: center; }
      .modal-title { font-size: 1.2rem; color: var(--color-primary); flex-shrink: 0; }
      .modal-close-btn { font-size: 24px; color: var(--color-text-dark); cursor: pointer; background: none; border: none; padding: 0 5px; line-height: 1; }
      .modal-close-btn:hover { color: var(--color-primary); }
      .modal-body { flex-grow: 1; overflow-y: auto; }
      .modal-body p { line-height: 1.6; color: var(--color-text-medium); }
      .modal-footer { margin-top: 20px; display: flex; justify-content: flex-end; gap: 15px; }
      .save-slot { background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(201, 170, 113, 0.3); border-radius: 5px; padding: 15px; display: flex; margin-bottom: 15px; }
      .save-slot-info { flex-grow: 1; display: flex; flex-direction: column; min-width: 0; }
      .slot-name { font-size: 16px; color: var(--color-text-light); }
      .slot-time { font-size: 12px; color: var(--color-text-dark); margin-top: 5px; }
      .slot-summary { font-size: 11px; color: #a09c91; margin-top: 8px; font-style: italic; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 450px; word-break: break-word; }
      .save-slot-actions { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 8px; margin-bottom: 12px; }
      #floating-settings-btn { position: fixed; bottom: 15px; left: 15px; z-index: 999; font-size: 1.8rem; padding: 8px; line-height: 1; background: transparent; border: none; color: var(--color-primary); cursor: pointer; transition: transform 0.3s ease, color 0.3s ease; text-shadow: 1px 1px 5px rgba(0,0,0,0.7); }
      #floating-settings-btn:hover { transform: scale(1.1); color: var(--color-primary-hover); }
      #settings-modal-body { display: flex; flex-direction: column; gap: 25px; padding: 20px 10px; }
      .settings-group { display: flex; align-items: center; justify-content: space-between; padding-bottom: 15px; border-bottom: 1px solid rgba(201, 170, 113, 0.2); }
      .settings-group:last-child { border-bottom: none; }
      .settings-label { font-size: 1.1rem; color: var(--color-primary); }
      .settings-controls { display: flex; align-items: center; gap: 15px; }
      .settings-slider-group { display: flex; flex-direction: column; gap: 15px; margin-top: 15px; padding-left: 0; }
      .slider-container { display: flex; align-items: center; gap: 10px; width: 100%; }
      .slider-container label { flex-shrink: 0; width: 100px; color: var(--color-text-medium); }
      .slider-container input[type="range"] { flex-grow: 1; -webkit-appearance: none; appearance: none; width: 100%; height: 8px; background: rgba(0,0,0,0.5); outline: none; border: 1px solid var(--color-text-dark); border-radius: 5px; }
      .slider-container input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 20px; height: 20px; background: var(--color-primary); cursor: pointer; border-radius: 50%; border: 2px solid #fff; }
      .slider-container input[type="range"]::-moz-range-thumb { width: 20px; height: 20px; background: var(--color-primary); cursor: pointer; border-radius: 50%; border: 2px solid #fff; }
      .slider-value { min-width: 40px; text-align: right; color: #fff; }
      .toggle-switch { position: relative; display: inline-block; width: 40px; height: 20px; }
      .toggle-switch input { opacity: 0; width: 0; height: 0; }
      .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #6c757d; transition: .4s; border-radius: 20px; }
      .slider:before { position: absolute; content: ""; height: 14px; width: 14px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
      input:checked + .slider { background-color: var(--color-primary); }
      input:checked + .slider:before { transform: translateX(20px); }
      #about-guixu-modal { justify-content: center; align-items: center; background: rgba(0, 0, 0, 0.4); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); }
      #about-guixu-modal .modal-content { width: 95%; max-width: 950px; height: 90%; max-height: 80vh; padding: 0; background: rgba(15, 15, 35, 0.5); animation: fadeIn 0.3s ease forwards; border: 1px solid var(--color-border); }
      #about-guixu-modal .modal-header { padding: 10px 20px; margin-bottom: 0; border-bottom: none; justify-content: center; }
      #about-guixu-modal .modal-title { font-size: 1.2rem; }
      .about-modal-body { display: flex; flex-direction: column; padding: 10px 20px 10px 20px; gap: 10px; flex-grow: 1; overflow: hidden; }
      .about-tabs { display: flex; flex-shrink: 0; border-bottom: none; justify-content: space-around; }
      .about-tab-btn { background: transparent; border: none; color: var(--color-text-medium); padding: 10px 15px; cursor: pointer; border-bottom: 2px solid transparent; transition: all 0.3s ease; font-size: 0.9rem; }
      .about-tab-btn:hover { color: var(--color-primary); background-color: rgba(201, 170, 113, 0.1); }
      .about-tab-btn.active { color: var(--color-primary); border-bottom-color: var(--color-primary); }
      .about-tab-content { display: none; flex-grow: 1; overflow-y: auto; padding: 5px 15px 5px 5px; line-height: 1.7; color: var(--color-text-light); word-break: break-word; }
      .about-tab-content.active { display: block; }
      .about-tab-content h3 { color: var(--color-primary); font-size: 1.25em; margin: 1.5em 0 0.8em 0; padding-bottom: 0; border-bottom: none; }
      .about-tab-content h4 { color: #daa520; font-size: 1.1em; font-weight: bold; margin: 1.2em 0 0.6em 0; }
      .about-tab-content p { margin: 0 0 0.7em 0; }
      .about-tab-content strong { color: #ffd700; }
      .about-tab-content a { color: #87CEEB; text-decoration: none; font-weight: bold; }
      .about-tab-content a:hover { text-decoration: underline; }
      .about-tab-content ul, .about-tab-content ol { padding-left: 25px; }
      .about-tab-content li { margin-bottom: 0.5em; }
      .about-tab-content blockquote { border-left: 3px solid var(--color-primary); padding-left: 15px; margin-left: 5px; color: var(--color-text-medium); font-style: italic; }
      .about-modal-footer { flex-shrink: 0; display: flex; justify-content: flex-end; align-items: center; gap: 15px; padding: 10px 20px; border-top: none; margin-top: 10px; }
      .redemption-container { display: none; flex-grow: 1; align-items: center; gap: 10px; }
      .redemption-container.visible { display: flex; }
      #redemption-code-input { padding: 8px 12px; font-size: 0.9rem; flex-grow: 1; max-width: 300px; margin-left: 0; }
      #redemption-code-btn { padding: 8px 15px; font-size: 0.9rem; margin-left: 0; flex-shrink: 0; }
      #about-countdown-timer { color: var(--color-text-medium); font-style: italic; }
      #about-read-btn:disabled { background: #5a5a5a; cursor: not-allowed; border-color: #777; color: #aaa; }
      @media (max-width: 768px) {
        .content-wrapper { padding: 10px; max-height: 95vh; }
        .title { font-size: clamp(2rem, 8vw, 2.5rem); }
        .main-menu-btn { padding: 12px 0; font-size: 1.2rem; }
        #main-page-content .main-menu-btn { font-size: 1rem; padding: 10px 15px; }
        #main-page-content div[style*='gap: 20px'] { flex-direction: column; gap: 15px !important; }
        .preset-editor-layout { flex-direction: column; gap: 0; }
        .preset-list-panel { max-width: 100%; margin-bottom: 20px; }
        .preset-details-panel { margin-left: 0; padding: 15px; }
        .preset-editor-layout.mobile-details-view .preset-list-panel { display: none; }
        .preset-editor-layout:not(.mobile-details-view) .preset-details-panel { display: none; }
        .preset-editor-layout.mobile-details-view #preset-back-to-list-btn { display: inline-block; }
        .preset-basic-info, .preset-actions-grid { grid-template-columns: 1fr; }
        .talent-selection-container { flex-direction: column; }
        .action-btn { padding: 12px; }
        .editor-item .item-header { flex-direction: column; align-items: flex-start; gap: 5px; margin-bottom: 12px; }
        .editor-item .item-header span { font-size: 0.8rem; }
        .modal-content, #save-load-modal .modal-content, #default-import-modal .modal-content { width: 95%; padding: 20px; max-height: 80vh; }
        #worldbook-editor-modal .modal-form-grid { grid-template-columns: 1fr; }
        .startup-choice-layout { flex-direction: column; }
        .attributes-grid { grid-template-columns: 1fr; }
        .difficulty-selection, .talent-selection { grid-template-columns: 1fr; }
      }
    </style>
  </head>
  <body>
    <div id="startup-page">
      <div class="content-wrapper">
        <div id="main-page-content">
          <h1 id="main-title" class="title">归墟：【开局前端编辑器】</h1>
          <div class="credits-container">
            <p class="credits-author">作者: 类脑 / 旅途-梦星</p>
            <p class="credits-musings">【赞美梦星大人！！！）】</p>
          </div>
          <div id="world-book-controls" class="panel-section" style="padding: 15px; margin-bottom: 20px; max-width: 350px; margin-left: auto; margin-right: auto">
            <div class="section-title" style="font-size: 1.2rem; margin-bottom: 15px">世界书预设</div>
            <div style="display: flex; flex-direction: column; gap: 15px">
              <div class="d-flex align-items-center justify-content-between">
                <label for="unified-index-input" class="auto-write-label" style="font-size: 1rem; color: #c9aa71">读写序号:</label>
                <div class="d-flex align-items-center gap-5">
                    <input type="number" id="unified-index-input" value="1" min="1" style="width: 60px; background: rgba(0, 0, 0, 0.5); border: 1px solid #8b7355; color: #e0dcd1; border-radius: 4px; padding: 8px; font-size: 1rem; text-align: center; -moz-appearance: textfield;" />
                    <div class="d-flex flex-column gap-2">
                        <button id="index-increment-btn" class="index-stepper-btn" aria-label="增加序号">△</button>
                        <button id="index-decrement-btn" class="index-stepper-btn" aria-label="减少序号">▽</button>
                    </div>
                </div>
              </div>
              <div style="display: flex; align-items: center; justify-content: center; gap: 10px">
                <input type="checkbox" id="auto-toggle-lorebook-checkbox" style="cursor: pointer; width: 18px; height: 18px" />
                <label for="auto-toggle-lorebook-checkbox" class="auto-write-label" style="font-size: 1rem; color: #c9aa71">自动开关世界书</label>
              </div>
            </div>
          </div>
          <!-- ★★★ HTML 修正处 ★★★ -->
          <div id="main-menu-container">
            <button id="start-game-btn" class="main-menu-btn">开启游玩！！</button>
            <button id="show-save-manager-btn" class="main-menu-btn">存档管理</button>
            <button id="show-editor-btn" class="main-menu-btn">天赋/背景编辑器</button>
            <button id="clear-cache-btn" class="main-menu-btn">清除缓存</button>
          </div>
        </div>
        <div id="startup-choice-container" style="display: none"></div>
        <form id="setup-form" style="display: none"></form>
        <div id="editor-container" style="display: none; width: 100%; max-width: 1000px">
          <div class="tab-buttons" style="display: flex; justify-content: center; gap: 10px; margin-bottom: 20px">
            <button class="tab-button active" data-tab="talents">天赋编辑器</button>
            <button class="tab-button" data-tab="backgrounds">背景编辑器</button>
            <button class="tab-button" data-tab="worldbooks">世界书编辑器</button>
            <button class="tab-button" data-tab="presets">预设开局</button>
          </div>
          <div class="tab-content">
            <div id="talents-tab" class="tab-pane active" style="display: block">
              <h2>天赋编辑器</h2>
              <div id="talent-list-container" class="editor-list-container"></div>
              <button id="add-new-talent-btn" class="editor-btn btn-primary" style="margin-top: 15px">添加新天赋</button>
            </div>
            <div id="backgrounds-tab" class="tab-pane" style="display: none">
              <h2>背景编辑器</h2>
              <div id="background-list-container" class="editor-list-container"></div>
              <button id="add-new-background-btn" class="editor-btn btn-primary" style="margin-top: 15px">添加新背景</button>
            </div>
            <div id="worldbooks-tab" class="tab-pane" style="display: none">
              <h2>世界书编辑器</h2>
              <div class="wb-filter-controls">
                <div class="wb-filter-buttons">
                  <button class="wb-filter-btn active" data-filter="all">全部</button>
                  <button class="wb-filter-btn" data-filter="general">世界书</button>
                  <button class="wb-filter-btn" data-filter="preset">预设</button>
                  <button class="wb-filter-btn" data-filter="talent">天赋</button>
                  <button class="wb-filter-btn" data-filter="background">背景</button>
                </div>
                <div class="wb-search-controls">
                  <input type="search" id="wb-search-input" placeholder="搜索标题或内容..." class="modal-input" />
                  <button id="wb-refresh-btn" class="editor-btn">刷新数据</button>
                </div>
              </div>
              <div id="worldbook-list-container" class="editor-list-container"></div>
              <div style="margin-top: 15px; display: flex; justify-content: center; gap: 10px;">
                <button id="add-new-worldbook-btn" class="editor-btn">添加新世界书</button>
                <button id="add-preset-worldbook-btn" class="editor-btn">创建预设专属条目</button>
              </div>
            </div>
            <div id="presets-tab" class="tab-pane" style="display: none">
              <h2>预设开局编辑器</h2>
              <div class="preset-editor-layout">
                <div class="preset-list-panel">
                  <div id="preset-list-container" class="preset-selection-list"></div>
                  <div class="preset-actions">
                    <button id="add-new-preset-btn" class="editor-btn btn-primary">创建新预设</button>
                    <button id="import-preset-btn" class="editor-btn">导入</button>
                    <button id="export-preset-btn" class="editor-btn">导出</button>
                  </div>
                </div>
                <div class="preset-details-panel" id="preset-details-panel">
                  <button type="button" id="preset-back-to-list-btn">< 返回预设列表</button>
                  <div class="preset-header">
                    <div class="preset-basic-info">
                      <div class="modal-form-group"><label for="preset-name">预设名称</label><input type="text" id="preset-name" class="modal-input" /></div>
                      <div class="modal-form-group"><label for="preset-author">作者</label><input type="text" id="preset-author" class="modal-input" /></div>
                      <div class="modal-form-group"><label for="preset-series">系列</label><input type="text" id="preset-series" class="modal-input" placeholder="如：剑道、法术等" /></div>
                      <div class="modal-form-group"><label for="preset-points">预设点数</label><input type="number" id="preset-points" class="modal-input" /></div>
                    </div>
                  </div>
                  <div id="preset-controls-container"></div>
                  <div id="preset-details-collapsible-area">
                    <div class="preset-tabs">
                      <button class="preset-tab-btn active" data-tab="attributes">属性配置</button>
                      <button class="preset-tab-btn" data-tab="talents">天赋选择</button>
                      <button class="preset-tab-btn" data-tab="series">系列内容</button>
                      <button class="preset-tab-btn" data-tab="actions">操作</button>
                    </div>
                    <div class="preset-tab-content active" id="attributes-tab"><div class="attributes-grid" id="preset-attributes-grid"></div></div>
                    <div class="preset-tab-content" id="talents-tab-content"><div class="talent-selection-container"><div class="talent-selection-box"><h4>可用天赋</h4><div id="available-talents-list"></div></div><div class="talent-selection-box"><h4>已选天赋</h4><div id="selected-talents-list"></div></div></div></div>
                    <div class="preset-tab-content" id="series-tab"><div id="preset-series-content"></div></div>
                    <div class="preset-tab-content" id="actions-tab"><div class="preset-actions-grid"><button id="export-current-preset-btn" class="action-btn">导出系列包</button><button id="duplicate-current-preset-btn" class="action-btn">复制预设</button><button id="delete-current-preset-btn" class="action-btn btn-danger">删除预设</button></div></div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div class="global-controls" style="text-align: center; margin-top: 20px">
            <button id="import-all-btn" class="editor-btn">导入配置</button>
            <input type="file" id="import-file-input" style="display: none" accept=".json,.txt" />
            <button id="export-all-btn" class="editor-btn">导出所有配置</button>
            <button id="reset-editor-btn" class="editor-btn btn-danger">重置编辑器</button>
            <button id="back-to-main-btn" class="editor-btn">返回主页</button>
          </div>
        </div>
        <div id="editor-modal" class="editor-modal"><div class="modal-content"><h2 id="modal-title">编辑</h2><form id="modal-form"><input type="hidden" id="modal-item-type" /><input type="hidden" id="modal-edit-identifier" /><input type="hidden" id="modal-edit-uid" /><div class="modal-form-group"><label for="modal-name">名称 (唯一标识)</label><input type="text" id="modal-name" class="modal-input" required /></div><div class="modal-form-group"><label for="modal-author">作者</label><input type="text" id="modal-author" class="modal-input" required /></div><div class="modal-form-group"><label for="modal-series">系列</label><input type="text" id="modal-series" class="modal-input" placeholder="可选项，如：剑道、丹道" /></div><div class="modal-form-group" id="modal-cost-group"><label for="modal-cost">消耗点数</label><input type="number" id="modal-cost" class="modal-input" required /></div><div class="modal-form-group"><label for="modal-description">描述</label><textarea id="modal-description" class="modal-textarea" rows="4" required></textarea></div><div class="modal-form-group" id="modal-initial-resources-group" style="display: none;"><label for="modal-initial-resources">初始资源 (每行一个)</label><textarea id="modal-initial-resources" class="modal-textarea" rows="4"></textarea></div><div class="modal-actions"><button type="button" id="modal-cancel-btn" class="editor-btn">取消</button><button type="button" id="modal-save-btn" class="editor-btn btn-primary">保存</button></div></form></div></div>
        <div id="worldbook-editor-modal" class="editor-modal"><div class="modal-content"><h2 id="wb-modal-title">编辑世界书条目</h2><form id="wb-modal-form"><input type="hidden" id="wb-modal-edit-uid" /><input type="hidden" id="wb-modal-preset-series" /><input type="hidden" id="wb-modal-preset-author" /><div class="modal-form-group"><label for="wb-modal-comment">标题 (Comment)</label><input type="text" id="wb-modal-comment" class="modal-input" required /></div><div class="modal-form-group"><label for="wb-modal-content">内容 (Content)</label><textarea id="wb-modal-content" class="modal-textarea" rows="6" required></textarea></div><div class="modal-form-group"><label for="wb-modal-keys">关键词 (逗号分隔, 仅“选择性”策略生效)</label><textarea id="wb-modal-keys" class="modal-textarea" rows="2"></textarea></div><div class="modal-form-grid"><div class="modal-form-group"><label for="wb-position-type">插入位置</label><select id="wb-position-type" class="modal-select"><option value="before_character_definition">角色定义前</option><option value="after_character_definition">角色定义后</option><option value="before_example_messages">示例消息前</option><option value="after_example_messages">示例消息后</option><option value="before_author_note">作者注释前</option><option value="after_author_note">作者注释后</option><option value="at_depth">指定深度</option></select></div><div class="modal-form-group"><label for="wb-position-order">插入顺序</label><input type="number" id="wb-position-order" class="modal-input" value="100"></div></div><div id="wb-depth-settings" style="display:none;" class="modal-form-grid"><div class="modal-form-group"><label for="wb-position-depth">深度 (Depth)</label><input type="number" id="wb-position-depth" class="modal-input" value="0"></div><div class="modal-form-group"><label for="wb-position-role">角色 (Role)</label><select id="wb-position-role" class="modal-select"><option value="system">系统 (System)</option><option value="user">用户 (User)</option><option value="assistant">助手 (Assistant)</option></select></div></div><div class="modal-form-grid"><div class="modal-form-group"><label>激活策略</label><button type="button" id="wb-strategy-toggle-btn" class="editor-btn" style="width:100%; margin-left:0;"></button></div><div class="modal-form-group" style="display: flex; flex-direction: column; justify-content: center; gap: 10px;"><div style="display: flex; align-items: center; gap: 10px;"><input type="checkbox" id="wb-recursion-incoming" style="width: 18px; height: 18px; cursor: pointer;"><label for="wb-recursion-incoming" style="margin-bottom: 0; cursor: pointer;">不可递归</label></div><div style="display: flex; align-items: center; gap: 10px;"><input type="checkbox" id="wb-recursion-outgoing" style="width: 18px; height: 18px; cursor: pointer;"><label for="wb-recursion-outgoing" style="margin-bottom: 0; cursor: pointer;">防止进一步递归</label></div></div></div><div class="modal-form-group" style="display: flex; align-items: center; gap: 10px;"><input type="checkbox" id="wb-modal-enabled" style="width: 18px; height: 18px; cursor: pointer;"><label for="wb-modal-enabled" style="margin-bottom: 0; cursor: pointer;">启用此条目</label></div><div class="modal-actions"><button type="button" id="wb-modal-cancel-btn" class="editor-btn">取消</button><button type="button" id="wb-modal-save-btn" class="editor-btn btn-primary">保存</button></div></form></div></div>
      </div>
      <div id="loading-overlay" class="loading-overlay"><p>正在衍化天机，构筑您的宿命...</p></div>
    </div>
    <div id="save-load-modal" class="modal-overlay"><div class="modal-content"><div class="modal-header"><h2 class="modal-title">读档 / 管理</h2><div class="modal-header-actions"><button data-action="import-save" class="theme-btn theme-btn-gold btn-small">导入存档</button><button data-action="clear-all-saves" class="theme-btn theme-btn-red btn-small">清除所有存档</button><button data-action="close-modal" class="modal-close-btn" aria-label="关闭">×</button></div></div><div class="modal-body"></div></div></div>
    <input type="file" id="import-save-file-input" style="display: none;" accept=".json" />
    <div id="default-import-modal" class="modal-overlay"><div class="modal-content" style="max-width: 500px;"><div class="modal-header"><h2 class="modal-title">初始化向导</h2></div><div class="modal-body"><p>检测到您的【归墟（拼好卡）】世界书为空或不存在。</p><p>是否要导入一套默认的天赋和背景作为开局模板？您也可以选择稍后手动创建或从文件导入。</p></div><div class="modal-footer"><button id="import-defaults-later-btn" class="theme-btn">以后再说</button><button id="import-defaults-confirm-btn" class="theme-btn theme-btn-gold">确认导入</button></div></div></div>
    <button id="about-guixu-btn" aria-label="关于归墟">关于</button>
    <div id="about-guixu-modal" class="modal-overlay"><div class="modal-content"><div class="modal-header"><h2 class="modal-title">关于归墟</h2></div><div class="modal-body about-modal-body"><div class="about-tabs"><button class="about-tab-btn active" data-tab="credits">感谢名单</button><button class="about-tab-btn" data-tab="editor-guide">编辑器说明</button><button class="about-tab-btn" data-tab="version-info">版本介绍</button></div><div class="about-tab-content active" data-tab-content="credits"></div><div class="about-tab-content" data-tab-content="editor-guide"></div><div class="about-tab-content" data-tab-content="version-info"></div></div><div class="modal-footer about-modal-footer"><div id="redemption-container" class="redemption-container"><input type="text" id="redemption-code-input" class="modal-input" placeholder="输入跳过码..."><button id="redemption-code-btn" class="editor-btn">兑换</button></div><span id="about-countdown-timer"></span><button id="about-read-btn" class="editor-btn btn-primary" disabled>已阅读</button></div></div></div>
    <button id="floating-settings-btn" data-action="show-settings" aria-label="打开设置">⚙️</button>
    <div id="settings-modal" class="modal-overlay"><div class="modal-content"><div class="modal-header"><h2 class="modal-title">背景设置</h2><button id="modal-close-settings-btn" class="modal-close-btn" aria-label="关闭">×</button></div><div class="modal-body" id="settings-modal-body"></div></div></div>
    <input type="file" id="local-bg-input" style="display: none;" accept="image/*" />

    <script>
      // 类脑/旅程梦星作品，禁止二传，禁止商业化，均无偿免费开源分享
      (function () {
        // --- API 可用性检查 ---
        /* global TavernHelper, eventEmit, getChatMessages, getCurrentMessageId */
        if (
          typeof TavernHelper === 'undefined' ||
          typeof TavernHelper.getWorldbook === 'undefined' || // 检查新API是否存在
          typeof eventEmit === 'undefined' ||
          typeof getChatMessages === 'undefined' ||
          typeof getCurrentMessageId === 'undefined'
        ) {
          console.error('TavernHelper API 或事件系统未找到，或者版本过旧。');
          document.addEventListener('DOMContentLoaded', () => {
            document.body.innerHTML =
              '<h1 style="color: red; text-align: center;">错误：SillyTavern 环境 API 未找到或不兼容。请确保TavernHelper插件已更新。</h1>';
          });
          return;
        }

        // --- YAML解析器 (Stack-based to handle nesting) ---
        const YAMLParser = {
          parse: function (text) {
            if (!text || typeof text !== 'string') return {};
            const lines = text.split('\n');
            const result = {};
            const stack = [{ indent: -1, obj: result, lastKey: null }];

            for (const line of lines) {
                const trimmed = line.trim();
                if (!trimmed || trimmed.startsWith('#')) continue;

                const indent = line.search(/\S/);

                while (stack.length > 1 && indent <= stack[stack.length - 1].indent) {
                    stack.pop();
                }
                const parent = stack[stack.length - 1].obj;
                let lastKeyInParent = stack[stack.length - 1].lastKey;

                if (trimmed.startsWith('- ')) {
                    const value = trimmed.substring(2).trim();
                    if (lastKeyInParent && Array.isArray(parent[lastKeyInParent])) {
                        parent[lastKeyInParent].push(this._parseValue(value));
                    }
                } else {
                    const colonIndex = trimmed.indexOf(':');
                    if (colonIndex > -1) {
                        const key = trimmed.substring(0, colonIndex).trim();
                        let value = trimmed.substring(colonIndex + 1).trim();
                        
                        stack[stack.length - 1].lastKey = key;

                        if (value === '|' || value === '>') {
                            let multiline = '';
                            const blockStartIndex = lines.indexOf(line) + 1;
                            for (let i = blockStartIndex; i < lines.length; i++) {
                                const nextLine = lines[i];
                                const nextIndent = nextLine.search(/\S/);
                                if (nextLine.trim() === '' || nextIndent > indent) {
                                    multiline += nextLine.substring(indent + 2) + '\n';
                                } else {
                                    break;
                                }
                            }
                            parent[key] = multiline.trim();
                        } else if (value === '') {
                             const nextLine = lines[lines.indexOf(line) + 1] || '';
                             const nextTrimmed = nextLine.trim();
                             const nextIndent = nextLine.search(/\S/);
                             if (nextTrimmed.startsWith('- ') && nextIndent > indent) {
                                 const newArr = [];
                                 parent[key] = newArr;
                             } else if (nextIndent > indent) {
                                 const newObj = {};
                                 parent[key] = newObj;
                                 stack.push({ indent: indent, obj: newObj, lastKey: null });
                             } else {
                                 parent[key] = '';
                             }
                        } else {
                            parent[key] = this._parseValue(value);
                        }
                    }
                }
            }
            return result;
          },

          stringify: function (data, indent = '') {
            let yaml = '';
            for (const [key, value] of Object.entries(data)) {
              if (Array.isArray(value)) {
                yaml += `${indent}${key}:\n`;
                for (const item of value) {
                  yaml += `${indent}  - ${item}\n`;
                }
              } else if (typeof value === 'object' && value !== null) {
                yaml += `${indent}${key}:\n`;
                yaml += this.stringify(value, indent + '  ');
              } else if (typeof value === 'string' && value.includes('\n')) {
                yaml += `${indent}${key}: |\n`;
                const lines = value.split('\n');
                for (const line of lines) {
                  yaml += `${indent}  ${line}\n`;
                }
              } else {
                yaml += `${indent}${key}: ${value}\n`;
              }
            }
            return yaml;
          },

          _parseValue: function (val) {
            const numVal = Number(val);
            if (!isNaN(numVal) && val.trim() !== '') {
              return numVal;
            }
            if (val === 'true') return true;
            if (val === 'false') return false;
            return val;
          },
        };

        // --- 世界书数据管理器 (已使用新版API重写) ---
        const WorldBookManager = {
          LOREBOOK_NAME: '归墟（拼好卡）',

          parseCommentTitle(comment) {
            const result = {
              type: '',
              series: '',
              name: '',
              author: '未知',
            };
            // New Regex to capture 【世界书】【系列】【作者】标题
            const matchExtendedWB = comment.match(/^【(世界书)】【([^】]+)】【([^】]+)】(.+)$/);
            const match1 = comment.match(/^【(天赋|背景|预设)】【([^】]+)】([^【]+)【([^】]+)】$/);
            const match2 = comment.match(/^【(天赋|背景|预设|世界书)】([^【]+)【([^】]+)】$/);

            if (matchExtendedWB) {
                result.type = matchExtendedWB[1];
                result.series = matchExtendedWB[2];
                result.author = matchExtendedWB[3];
                result.name = matchExtendedWB[4].trim();
            } else if (match1) {
              result.type = match1[1];
              result.series = match1[2];
              result.name = match1[3].trim();
              result.author = match1[4];
            } else if (match2) {
              result.type = match2[1];
              result.name = match2[2].trim();
              result.author = match2[3];
            } else {
              const oldMatch = comment.match(/^【(天赋|背景|预设|世界书)】(.+)$/);
              if (oldMatch) {
                result.type = oldMatch[1];
                result.name = oldMatch[2].trim();
              }
            }
            return result;
          },

          generateCommentTitle(type, name, author, series = '') {
            const typeMap = { talent: '天赋', background: '背景', preset: '预设', worldbook: '世界书' };
            const typeText = typeMap[type] || type;
            const seriesString = String(series || '').trim();
            if (seriesString) {
              return `【${typeText}】【${seriesString}】${name}【${author}】`;
            } else {
              if (type === 'worldbook') {
                  return `【${typeText}】${name}`;
              }
              return `【${typeText}】${name}【${author}】`;
            }
          },

          async loadAllData() {
            try {
              let allEntries;
              try {
                allEntries = await TavernHelper.getWorldbook(this.LOREBOOK_NAME);
              } catch (e) {
                console.warn(`世界书 "${this.LOREBOOK_NAME}" 不存在或加载失败，尝试创建...`, e);
                const created = await TavernHelper.createWorldbook(this.LOREBOOK_NAME);
                if (created) {
                  console.log(`世界书 "${this.LOREBOOK_NAME}" 创建成功。`);
                  allEntries = [];
                } else {
                  throw new Error(`无法创建世界书 "${this.LOREBOOK_NAME}"。`);
                }
              }

              const talents = [];
              const backgrounds = [];
              const presets = [];
              const worldbookEntries = [];

              if (!allEntries || allEntries.length === 0) {
                console.log('世界书为空或不存在。');
                return { talents: [], backgrounds: [], presets: [], worldbookEntries: [], isEmpty: true };
              }

              for (const entry of allEntries) {
                try {
                  const titleInfo = this.parseCommentTitle(entry.name);
                  const yamlData = YAMLParser.parse(entry.content);

                  if (entry.name.startsWith('【天赋】')) {
                      const parsedName = titleInfo.name || entry.name.replace(/^【天赋】/, '').split('【')[0].trim();
                      talents.push({
                        id: parsedName,
                        name: parsedName,
                        author: titleInfo.author,
                        series: titleInfo.series || yamlData.系列 || '',
                        cost: parseInt(yamlData.消耗点数) || 0,
                        description: yamlData.描述 || '',
                        isFromWorldBook: true,
                        originalComment: entry.name,
                        uid: entry.uid,
                      });
                      worldbookEntries.push(entry);
                  } else if (entry.name.startsWith('【背景】')) {
                      const parsedName = titleInfo.name || entry.name.replace(/^【背景】/, '').split('【')[0].trim();
                      backgrounds.push({
                        id: parsedName,
                        name: parsedName,
                        author: titleInfo.author,
                                        series: titleInfo.series || yamlData.系列 || '',
                description: yamlData.描述 || '',
                initialResources: yamlData.初始资源 || [],
                isFromWorldBook: true,
                originalComment: entry.name,
                uid: entry.uid,
              });
              worldbookEntries.push(entry);
          } else if (entry.name.startsWith('【预设】')) {
              const parsedName = titleInfo.name || entry.name.replace(/^【预设】/, '').split('【')[0].trim();
              presets.push({
                id: parsedName,
                name: parsedName,
                author: titleInfo.author,
                series: titleInfo.series || yamlData.系列 || '',
                points: parseInt(yamlData.点数) || 40,
                description: yamlData.描述 || '',
                attributes: yamlData.属性分配 || {},
                requiredTalents: yamlData.必选天赋 || [],
                optionalTalents: yamlData.可选天赋 || [],
                isFromWorldBook: true,
                originalComment: entry.name,
                uid: entry.uid,
                enabled: entry.enabled,
              });
              worldbookEntries.push(entry);
          } else {
            worldbookEntries.push(entry);
          }
        } catch (e) {
          console.warn('解析世界书条目失败:', entry.name, e);
        }
      }
      return { talents, backgrounds, presets, worldbookEntries, isEmpty: false };
    } catch (error) {
      console.error('从世界书加载数据失败:', error);
      return { talents: [], backgrounds: [], presets: [], worldbookEntries: [], isEmpty: true };
    }
  },
  
  async _saveOrUpdateWith(updaterFn) {
      try {
          await TavernHelper.updateWorldbookWith(this.LOREBOOK_NAME, updaterFn);
          return true;
      } catch (error) {
          console.error('更新世界书失败:', error);
          return false;
      }
  },

  async saveTalentOrBackground(itemData, type) {
    const entryToSave = { ...itemData }; 

    entryToSave.name = this.generateCommentTitle(type, itemData.name, itemData.author, itemData.series);
    
    if (type === 'talent') {
        entryToSave.content = YAMLParser.stringify({
            消耗点数: itemData.cost || 0,
            系列: itemData.series || '',
            描述: itemData.description || '',
        });
    } else { // background
        entryToSave.content = YAMLParser.stringify({
            系列: itemData.series || '',
            描述: itemData.description || '',
            初始资源: itemData.initialResources || [],
        });
    }

    if (typeof entryToSave.enabled === 'undefined') entryToSave.enabled = false;
    if (typeof entryToSave.strategy === 'undefined') entryToSave.strategy = { type: 'selective', keys: [entryToSave.name.replace(/【|】/g, '')] };
    if (typeof entryToSave.position === 'undefined') entryToSave.position = { type: 'before_character_definition', order: type === 'talent' ? 100 : 200 };

    // 清理前端专用属性
    const nonWbProps = ['cost', 'series', 'description', 'initialResources', 'author', 'id', 'isFromWorldBook', 'originalComment'];
    nonWbProps.forEach(prop => delete entryToSave[prop]);
    
    return this._saveOrUpdateWith(worldbook => {
        const index = entryToSave.uid ? worldbook.findIndex(e => String(e.uid) === String(entryToSave.uid)) : -1;
        if (index > -1) {
            worldbook[index] = { ...worldbook[index], ...entryToSave };
        } else {
            delete entryToSave.uid; 
            worldbook.push(entryToSave);
        }
        return worldbook;
    });
  },
  
  async savePreset(presetData) {
    const entryToSave = { ...presetData };

    entryToSave.name = this.generateCommentTitle('preset', presetData.name, presetData.author, presetData.series);
    
    entryToSave.content = YAMLParser.stringify({
      点数: presetData.points || 40,
      系列: presetData.series || '',
      描述: presetData.description || '',
      属性分配: presetData.attributes || {},
      必选天赋: presetData.requiredTalents || [],
      可选天赋: presetData.optionalTalents || [],
    });

    if (typeof entryToSave.enabled === 'undefined') entryToSave.enabled = false;
    if (typeof entryToSave.strategy === 'undefined') entryToSave.strategy = { type: 'selective', keys: [entryToSave.name.replace(/【|】/g, '')] };
    if (typeof entryToSave.position === 'undefined') entryToSave.position = { type: 'before_character_definition', order: 300 };
    
    const nonWbProps = ['points', 'series', 'description', 'attributes', 'requiredTalents', 'optionalTalents', 'author', 'id', 'isFromWorldBook', 'originalComment'];
    nonWbProps.forEach(prop => delete entryToSave[prop]);

    return this._saveOrUpdateWith(worldbook => {
      const index = entryToSave.uid ? worldbook.findIndex(e => String(e.uid) === String(entryToSave.uid)) : -1;
      if (index > -1) {
        worldbook[index] = { ...worldbook[index], ...entryToSave };
      } else {
        delete entryToSave.uid;
        worldbook.push(entryToSave);
      }
      return worldbook;
    });
  },

  async saveWorldBookEntry(entryData) {
    return this._saveOrUpdateWith(worldbook => {
      const entryIndex = entryData.uid ? worldbook.findIndex(e => String(e.uid) === String(entryData.uid)) : -1;
      if (entryIndex > -1) {
        worldbook[entryIndex] = { ...worldbook[entryIndex], ...entryData };
      } else {
        worldbook.push(entryData);
      }
      return worldbook;
    });
  },

  async deleteEntryByUid(uid) {
    if (typeof uid === 'undefined' || uid === null) {
        console.error('Attempted to delete an entry with an invalid UID');
        return false;
    }
    try {
        return await this._saveOrUpdateWith(worldbook => worldbook.filter(e => String(e.uid) !== String(uid)));
    } catch (error) {
        console.error(`Failed to delete worldbook entry with UID: ${uid}`, error);
        return false;
    }
  },
};

// --- 自动保存工具 ---
let saveDebounceTimer = null;

// --- 自定义模态框 ---
function showCustomModal(options) {
  return new Promise(resolve => {
    const config = {
      title: '提示',
      content: '',
      buttons: [{ text: '确认', value: true, class: 'btn-primary' }],
      inputType: null, 
      inputValue: '',
      ...options,
    };

    const existingModal = document.getElementById('custom-modal-overlay');
    if (existingModal) {
      existingModal.remove();
    }

    const modalOverlay = document.createElement('div');
    modalOverlay.id = 'custom-modal-overlay';
    modalOverlay.className = 'modal-overlay';
    modalOverlay.style.display = 'flex';
    modalOverlay.style.zIndex = '20000'; 

    let inputHtml = '';
    if (config.inputType) {
      inputHtml = `
        <div class="modal-form-group">
          <input type="${config.inputType}" id="custom-modal-input" class="modal-input" value="${config.inputValue}">
        </div>`;
    }

    modalOverlay.innerHTML = `
      <div class="modal-content" style="max-width: 450px;">
        <h2 class="modal-title">${config.title}</h2>
        <div class="modal-body" style="padding: 10px 0 20px; color: var(--color-text-light); white-space: pre-wrap;">${config.content}</div>
        ${inputHtml}
        <div class="modal-footer" style="justify-content: center;">
          ${config.buttons
            .map(
              btn =>
                `<button class="editor-btn ${btn.class || ''}" data-value="${btn.value}">${btn.text}</button>`
            )
            .join('')}
        </div>
      </div>
    `;

    document.body.appendChild(modalOverlay);
    const modalContent = modalOverlay.querySelector('.modal-content');
    modalContent.style.animation = 'fadeIn 0.3s ease forwards';

    modalOverlay.addEventListener('click', e => {
      const target = e.target;
      if (target.matches('.editor-btn')) {
        const buttonValue = target.dataset.value;
        let resolveValue;

        if (buttonValue === 'true') resolveValue = true;
        else if (buttonValue === 'false') resolveValue = false;
        else resolveValue = buttonValue;

        if (config.inputType) {
          const input = document.getElementById('custom-modal-input');
          if (resolveValue === true || (typeof resolveValue === 'string' && resolveValue !== 'cancel')) {
             resolve({ confirmed: true, value: input.value });
          } else {
             resolve({ confirmed: false, value: null });
          }
        } else {
          resolve(resolveValue);
        }
        modalOverlay.remove();
      }
    });
  });
}

async function guiXuAlert(content, title = '提示') {
  await showCustomModal({
    title: title,
    content: content,
    buttons: [{ text: '确定', value: true, class: 'btn-primary' }],
  });
}

async function guiXuConfirm(content, title = '请确认') {
  const result = await showCustomModal({
    title: title,
    content: content,
    buttons: [
      { text: '取消', value: false, class: '' },
      { text: '确定', value: true, class: 'btn-primary' },
    ],
  });
  return Boolean(result);
}

async function guiXuPrompt(content, defaultValue = '', title = '请输入') {
   const result = await showCustomModal({
    title: title,
    content: content,
    inputType: 'text',
    inputValue: defaultValue,
    buttons: [
      { text: '取消', value: 'cancel', class: '' },
      { text: '确定', value: true, class: 'btn-primary' },
    ],
  });
  
  if (result.confirmed) {
    return result.value;
  }
  return null;
}

function showSaveStatus(message, isSuccess = false, isError = false) {
  let statusIndicator = document.getElementById('preset-save-status');
  if (!statusIndicator) {
    statusIndicator = document.createElement('div');
    statusIndicator.id = 'preset-save-status';
    statusIndicator.style.position = 'fixed';
    statusIndicator.style.bottom = '20px';
    statusIndicator.style.right = '20px';
    statusIndicator.style.background = 'rgba(15, 15, 35, 0.9)';
    statusIndicator.style.border = '1px solid #c9aa71';
    statusIndicator.style.padding = '10px 20px';
    statusIndicator.style.borderRadius = '5px';
    statusIndicator.style.zIndex = '10001';
    statusIndicator.style.transition = 'opacity 0.5s ease, transform 0.3s ease';
    statusIndicator.style.opacity = '0';
    statusIndicator.style.transform = 'translateY(10px)';
    document.body.appendChild(statusIndicator);
  }

  statusIndicator.textContent = message;
  statusIndicator.style.color = isError ? '#ff6347' : isSuccess ? '#90ee90' : '#c9aa71';

  setTimeout(() => {
    statusIndicator.style.opacity = '1';
    statusIndicator.style.transform = 'translateY(0)';
  }, 50);

  if (isSuccess || isError) {
    setTimeout(() => {
      statusIndicator.style.opacity = '0';
      statusIndicator.style.transform = 'translateY(10px)';
    }, 2500);
  }
}

function debouncedSave() {
  if (!currentEditingPreset) return;
  clearTimeout(saveDebounceTimer);
  showSaveStatus('正在自动保存...');
  saveDebounceTimer = setTimeout(async () => {
    try {
      await saveCurrentPreset();
      showSaveStatus('已保存', true);
    } catch (e) {
      showSaveStatus(`保存失败: ${e.message}`, false, true);
    }
  }, 1500);
}

// --- 系列化数据管理器 ---
const SeriesManager = {
  getSeriesData(seriesName) {
    if (!seriesName || !seriesName.trim()) {
      return { talents: [], backgrounds: [], presets: [] };
    }
    const trimmedSeriesName = seriesName.trim();
    const seriesTalents = editorData.talents.filter(
      t => String(t.series || '').trim() === trimmedSeriesName
    );
    const seriesBackgrounds = editorData.backgrounds.filter(
      b => String(b.series || '').trim() === trimmedSeriesName
    );
    const seriesPresets = editorData.presets.filter(
      p => String(p.series || '').trim() === trimmedSeriesName
    );

    return {
      talents: seriesTalents,
      backgrounds: seriesBackgrounds,
      presets: seriesPresets,
    };
  },

  getAllSeries() {
    const series = new Set();
    editorData.talents.forEach(t => {
      if (t.series) series.add(String(t.series).trim());
    });
    editorData.backgrounds.forEach(b => {
      if (b.series) series.add(String(b.series).trim());
    });
    editorData.presets.forEach(p => {
      if (p.series) series.add(String(p.series).trim());
    });
    return Array.from(series).filter(s => s).sort();
  },
};

// --- 游戏核心数据 ---
const GAME_DATA = {
  difficulties: {
    hell: { name: '地狱模式', points: 10 },
    hard: { name: '困难模式', points: 20 },
    normal: { name: '普通模式', points: 40 },
    destiny: { name: '天命模式', points: 100 },
  },
  attributes: {
    fa_li: { name: '法力', description: '决定法术威力和法力值上限，影响施法能力和法术伤害' },
    shen_hai: { name: '神海', description: '决定神识强度和精神防御，影响感知能力和抗幻术能力' },
    dao_xin: { name: '道心', description: '决定修炼悟性和心境稳定，影响突破概率和抗心魔能力' },
    kong_su: { name: '空速', description: '决定移动速度和反应能力，影响闪避和先手概率' },
    qi_yun: {
      name: '气运',
      description:
        '决定运气和机缘，影响获得宝物和遇到奇遇的概率，以及各类判定的成功率，骰子气运修正等（消耗10点）',
    },
  },
  genders: {
    male: { name: '男性' },
    female: { name: '女性' },
    futanari: { name: '女生男相' },
    shemale: { name: '男生女相' },
    paramecium: { name: '草履虫' },
    helicopter: { name: '武装直升机' },
    mengxing: { name: '梦星' },
  },
};

// --- 新用户的默认数据 ---
const DEFAULT_EDITOR_DATA = {
  talents: [
    { id: '天生剑体', name: '天生剑体', author: '系统', series: '剑道', cost: 20, description: '对剑术的感悟远超常人。', },
    { id: '丹道宗师', name: '丹道宗师', author: '系统', series: '丹道', cost: 20, description: '在炼丹方面有无与伦比的天赋。', },
    { id: '阵法大家', name: '阵法大家', author: '系统', series: '阵法', cost: 20, description: '能轻易看破并布置强大的阵法。', },
    { id: '御兽奇才', name: '御兽奇才', author: '系统', series: '御兽', cost: 15, description: '与灵兽有天然的亲和力。', },
    { id: '天生神力', name: '天生神力', author: '系统', series: '', cost: 10, description: '你的力量远超常人。' },
    { id: '过目不忘', name: '过目不忘', author: '系统', series: '', cost: 10, description: '你看过的东西都能记住。' },
    { id: '炼器大师', name: '炼器大师', author: '系统', series: '炼器', cost: 20, description: '在炼器方面有无与伦比的天赋。', },
    { id: '天生灵体', name: '天生灵体', author: '系统', series: '', cost: 25, description: '修炼速度是常人的两倍。', },
    { id: '鸿运当头', name: '鸿运当头', author: '系统', series: '', cost: 50, description: '你的运气总是很好。气运+100', },
    { id: '百毒不侵', name: '百毒不侵', author: '系统', series: '', cost: 15, description: '你对所有毒素都有很强的抵抗力。', },
  ],
  backgrounds: [
    { id: '富家子弟', name: '富家子弟', author: '系统', series: '', description: '你出生在一个富裕的家庭，从小锦衣玉食。', initialResources: ['1000灵石', '精致的丝绸长袍'], },
    { id: '名门之后', name: '名门之后', author: '系统', series: '', description: '你的家族在当地享有盛誉。', initialResources: ['家族信物'] },
    { id: '书香门第', name: '书香门第', author: '系统', series: '', description: '你的家庭世代都是读书人。', initialResources: ['一本古籍'], },
    { id: '山野村夫', name: '山野村夫', author: '系统', series: '', description: '你出生在偏远的山村，过着与世无争的生活。', initialResources: ['一把柴刀', '粗布衣'], },
    { id: '孤儿', name: '孤儿', author: '系统', series: '', description: '你从小就是个孤儿，在街头流浪长大。', initialResources: ['半块干粮'] },
    { id: '魔道卧底', name: '魔道卧底', author: '系统', series: '', description: '你是魔道安插在正道的卧底。', initialResources: ['一瓶毒药', '传讯玉简'], },
    { id: '重生之人', name: '重生之人', author: '系统', series: '', description: '你带着前世的记忆重生了。', initialResources: [] },
  ],
  presets: [],
};

// --- 游戏状态 ---
const baseAttributes = {
  fa_li: 1,
  shen_hai: 1,
  dao_xin: 1,
  kong_su: 1,
  qi_yun: 10,
};

function getNewGameState() {
  return {
    currentStep: 'difficulty',
    selectedDifficulty: null,
    totalPoints: 0,
    spentAttributePoints: { fa_li: 0, shen_hai: 0, dao_xin: 0, kong_su: 0, qi_yun: 0 },
    selectedTalents: [],
    requiredTalents: [],
    customTalent: '',
    selectedBackground: null,
    customBackground: '',
    selectedGender: null,
    startingPresetName: null,
    get spentPoints() {
      let attributeCost = 0;
      for (const key in this.spentAttributePoints) {
        const spent = this.spentAttributePoints[key];
        attributeCost += (key === 'qi_yun') ? spent * 10 : spent;
      }
      const talentCost = this.selectedTalents.reduce((sum, talentId) => {
        const talent = editorData.talents.find(t => t.id === talentId || t.name === talentId);
        return sum + (talent ? talent.cost || 0 : 0);
      }, 0);
      return attributeCost + talentCost;
    },
    get remainingPoints() {
      return this.totalPoints - this.spentPoints;
    },
    get finalAttributes() {
      const final = {};
      for (const key in baseAttributes) {
        final[key] = (baseAttributes[key] || 0) + (this.spentAttributePoints[key] || 0);
      }
      return final;
    },
  };
}

let gameState = getNewGameState();

async function refreshLocalStorage() {
  try {
    ['guixu_equipped_items', 'guixu_pending_actions'].forEach(key => localStorage.removeItem(key));
    await guiXuAlert('缓存已清除！如果是新开聊天，这将有助于解决变量更新问题。');
  } catch (e) {
    console.error('清除缓存失败:', e);
    await guiXuAlert('清除缓存失败：' + e.message, '错误');
  }
}

// --- 编辑器数据（统一管理） ---
const editorData = {
  talents: [],
  backgrounds: [],
  presets: [],
  worldbookEntries: [],
  isLoading: false,
  lastLoadTime: null,
};

async function populateWorldBookWithDefaults() {
  console.log('正在使用默认数据填充世界书...');
  const { talents, backgrounds } = DEFAULT_EDITOR_DATA;
  let successCount = 0;
  let failCount = 0;
  for (const talent of talents) {
    try {
      if (await WorldBookManager.saveTalentOrBackground(talent, 'talent')) successCount++; else failCount++;
    } catch (e) {
      failCount++; console.error(`保存默认天赋失败: ${talent.name}`, e);
    }
  }
  for (const bg of backgrounds) {
    try {
      if (await WorldBookManager.saveTalentOrBackground(bg, 'background')) successCount++; else failCount++;
    } catch (e) {
      failCount++; console.error(`保存默认背景失败: ${bg.name}`, e);
    }
  }
  if (failCount > 0) {
    await guiXuAlert(`世界书初始化部分完成。成功: ${successCount}, 失败: ${failCount}。详情请查看控制台。`, '警告');
  } else {
    await guiXuAlert(`世界书初始化成功，共写入 ${successCount} 条默认数据。`);
  }
}

async function promptForDefaultImport() {
  return new Promise(resolve => {
    const modal = document.getElementById('default-import-modal');
    const confirmBtn = document.getElementById('import-defaults-confirm-btn');
    const laterBtn = document.getElementById('import-defaults-later-btn');
    modal.style.display = 'flex';
    const onConfirm = async () => {
      modal.style.display = 'none';
      document.getElementById('loading-overlay').style.display = 'flex';
      await populateWorldBookWithDefaults();
      document.getElementById('loading-overlay').style.display = 'none';
      cleanup();
      resolve(true);
    };
    const onLater = () => {
      modal.style.display = 'none';
      cleanup();
      resolve(false);
    };
    const cleanup = () => {
        confirmBtn.removeEventListener('click', onConfirm);
        laterBtn.removeEventListener('click', onLater);
    };
    confirmBtn.addEventListener('click', onConfirm);
    laterBtn.addEventListener('click', onLater);
  });
}

async function loadEditorData() {
  if (editorData.isLoading) return true;
  editorData.isLoading = true;
  document.getElementById('loading-overlay').style.display = 'flex';
  
  try {
    const loadingPlaceholder = `<div class="loading-placeholder">正在从世界书加载数据...</div>`;
    ['talent-list-container', 'background-list-container', 'preset-list-container', 'worldbook-list-container'].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.innerHTML = loadingPlaceholder;
    });

    console.log('开始从世界书加载编辑器数据...');
    const worldBookData = await WorldBookManager.loadAllData();

    if (worldBookData.isEmpty) {
      const imported = await promptForDefaultImport();
      if (imported) {
        const reloadedData = await WorldBookManager.loadAllData();
        Object.assign(editorData, {
            talents: reloadedData.talents || [],
            backgrounds: reloadedData.backgrounds || [],
            presets: reloadedData.presets || [],
            worldbookEntries: reloadedData.worldbookEntries || [],
        });
      } else {
        Object.assign(editorData, { talents: [], backgrounds: [], presets: [], worldbookEntries: [] });
      }
    } else {
      Object.assign(editorData, {
          talents: worldBookData.talents || [],
          backgrounds: worldBookData.backgrounds || [],
          presets: worldBookData.presets || [],
          worldbookEntries: worldBookData.worldbookEntries || [],
      });
    }

    editorData.lastLoadTime = Date.now();
    console.log(`编辑器数据加载完成: ${editorData.talents.length}个天赋, ${editorData.backgrounds.length}个背景, ${editorData.presets.length}个预设, ${editorData.worldbookEntries.length}个世界书条目`);
    renderAllEditors();
    return true;
  } catch (error) {
    console.error('加载编辑器数据时发生严重错误:', error);
    await guiXuAlert('加载编辑器数据失败，请检查控制台。\n错误: ' + error.message, '错误');
    return false;
  } finally {
    editorData.isLoading = false;
    document.getElementById('loading-overlay').style.display = 'none';
  }
}

async function resetEditorToDefaults() {
  const confirmed = await guiXuConfirm('确定要重置编辑器吗？这将删除世界书中所有【天赋】和【背景】条目，并重新写入默认数据。此操作不可撤销！', '重置确认');
  if (!confirmed) return;

  document.getElementById('loading-overlay').style.display = 'flex';
  try {
    await TavernHelper.updateWorldbookWith(WorldBookManager.LOREBOOK_NAME, (worldbook) => {
        return worldbook.filter(entry => {
            return !entry.name.startsWith('【天赋】') && !entry.name.startsWith('【背景】');
        });
    });
    await populateWorldBookWithDefaults();
    await loadEditorData();
  } catch (error) {
    console.error('重置编辑器失败:', error);
    await guiXuAlert('重置失败，详情请查看控制台。', '错误');
  } finally {
    document.getElementById('loading-overlay').style.display = 'none';
  }
}

// --- 编辑器渲染函数 ---
function renderTalentEditor() {
  const container = document.getElementById('talent-list-container');
  if (!container) return;
  container.innerHTML = '';

  if (editorData.talents.length === 0 && !editorData.isLoading) {
    container.innerHTML = '<div class="loading-placeholder">暂无天赋数据</div>';
    return;
  }

  editorData.talents.forEach(talent => {
    const seriesString = String(talent.series || '').trim();
    const seriesInfo = seriesString ? `[${seriesString}] ` : '';
    const item = document.createElement('div');
    item.classList.add('editor-item');
    item.innerHTML = `
      <div class="item-header">
        <strong>${seriesInfo}${talent.name}</strong>
        <span>(作者: ${talent.author || '未知'} | 消耗: ${talent.cost || 0}点)</span>
      </div>
      <p class="item-description">${talent.description || '暂无描述'}</p>
      <div class="item-actions">
        <button class="editor-btn edit-talent-btn" data-uid="${talent.uid}" data-name="${talent.name}">编辑</button>
        <button class="editor-btn btn-danger delete-talent-btn" data-uid="${talent.uid}" data-name="${talent.name}">删除</button>
      </div>
    `;
    container.appendChild(item);
  });
}

function renderBackgroundEditor() {
  const container = document.getElementById('background-list-container');
  if (!container) return;
  container.innerHTML = '';

  if (editorData.backgrounds.length === 0 && !editorData.isLoading) {
    container.innerHTML = '<div class="loading-placeholder">暂无背景数据</div>';
    return;
  }

  editorData.backgrounds.forEach(bg => {
    const seriesString = String(bg.series || '').trim();
    const seriesInfo = seriesString ? `[${seriesString}] ` : '';
    const item = document.createElement('div');
    item.classList.add('editor-item');
    item.innerHTML = `
      <div class="item-header">
        <strong>${seriesInfo}${bg.name}</strong>
        <span>(作者: ${bg.author || '未知'})</span>
      </div>
      <p class="item-description">${bg.description || '暂无描述'}</p>
      <div class="item-actions">
        <button class="editor-btn edit-background-btn" data-uid="${bg.uid}" data-name="${bg.name}">编辑</button>
        <button class="editor-btn btn-danger delete-background-btn" data-uid="${bg.uid}" data-name="${bg.name}">删除</button>
      </div>
    `;
    container.appendChild(item);
  });
}

function renderPresetEditor() {
  const container = document.getElementById('preset-list-container');
  if (!container) return;
  container.innerHTML = '';
  if (editorData.presets.length === 0 && !editorData.isLoading) {
    container.innerHTML = '<div class="loading-placeholder">暂无预设数据</div>';
    return;
  }
  editorData.presets.forEach(preset => {
    const item = document.createElement('div');
    item.classList.add('preset-list-item');
    if (currentEditingPreset && currentEditingPreset.name === preset.name) {
      item.classList.add('selected');
    }
    item.dataset.presetName = preset.name;
    const seriesString = String(preset.series || '').trim();
    const seriesInfo = seriesString ? `[${seriesString}] ` : '';
    item.innerHTML = `<strong>${seriesInfo}${preset.name}</strong><br><small>作者: ${preset.author || '未知'}</small>`;
    container.appendChild(item);
  });
}

let currentWbFilter = 'all';
function renderWorldBookEditor() {
    const container = document.getElementById('worldbook-list-container');
    if (!container) return;
    container.innerHTML = '';

    const searchInput = document.getElementById('wb-search-input');
    const searchTerm = searchInput ? searchInput.value.toLowerCase().trim() : '';

    const filterPrefixMap = {
        general: '【世界书】',
        preset: '【预设】',
        talent: '【天赋】',
        background: '【背景】'
    };

    let filteredEntries = editorData.worldbookEntries;

    // Step 1: Filter by category
    if (currentWbFilter !== 'all') {
        const prefix = filterPrefixMap[currentWbFilter];
        if (prefix) {
            filteredEntries = filteredEntries.filter(entry => entry.name.startsWith(prefix));
        }
    }
    
    // Step 2: Filter by search term
    if (searchTerm) {
        filteredEntries = filteredEntries.filter(entry => {
            const nameMatch = entry.name.toLowerCase().includes(searchTerm);
            const contentMatch = entry.content.toLowerCase().includes(searchTerm);
            return nameMatch || contentMatch;
        });
    }

    if (filteredEntries.length === 0 && !editorData.isLoading) {
        let placeholderText = '暂无世界书数据';
        if (searchTerm) {
            placeholderText = `未找到匹配 "${searchTerm}" 的条目`;
        } else if (currentWbFilter !== 'all') {
            placeholderText = `无匹配 "${filterPrefixMap[currentWbFilter] || ''}" 前缀的条目`;
        }
        container.innerHTML = `<div class="loading-placeholder">${placeholderText}</div>`;
        return;
    }

    const positionMap = {
        'before_character_definition': '角色前',
        'after_character_definition': '角色后',
        'before_example_messages': '示例前',
        'after_example_messages': '示例后',
        'before_author_note': '作者注前',
        'after_author_note': '作者注后',
        'at_depth': '指定深度'
    };

    filteredEntries.forEach(entry => {
        const item = document.createElement('div');
        item.classList.add('editor-item');
        item.dataset.uid = entry.uid;
        const statusClass = entry.enabled ? 'enabled' : 'disabled';
        const strategyClass = entry.strategy?.type || 'constant';
        const positionText = positionMap[entry.position?.type] || '未知位置';

        item.innerHTML = `
            <div class="wb-item-header">
                <div class="wb-item-title">
                    <span class="status-indicator ${statusClass}" title="${entry.enabled ? '已启用' : '已禁用'}"></span>
                    <span>${entry.name}</span>
                </div>
                <div class="wb-item-indicators">
                    <span class="strategy-indicator ${strategyClass}" title="策略: ${strategyClass}"></span>
                    <span>${positionText} (顺序: ${entry.position?.order ?? 'N/A'})</span>
                </div>
            </div>
            <p class="item-description">${entry.content || '无内容'}</p>
             <div class="item-actions">
                <button class="editor-btn toggle-wb-btn">
                    ${entry.enabled ? '禁用' : '启用'}
                </button>
                <button class="editor-btn edit-wb-btn">编辑</button>
                <button class="editor-btn btn-danger delete-wb-btn">删除</button>
            </div>
        `;
        container.appendChild(item);
    });
}


let currentEditingPreset = null;

// --- 编辑器模态框逻辑 ---
const modal = document.getElementById('editor-modal');
const modalForm = document.getElementById('modal-form');
const modalTitle = document.getElementById('modal-title');
const modalItemType = document.getElementById('modal-item-type');
const modalEditIdentifier = document.getElementById('modal-edit-identifier');
const modalEditUid = document.getElementById('modal-edit-uid');
const modalNameInput = document.getElementById('modal-name');
const modalAuthorInput = document.getElementById('modal-author');
const modalSeriesInput = document.getElementById('modal-series');
const modalCostGroup = document.getElementById('modal-cost-group');
const modalCostInput = document.getElementById('modal-cost');
const modalDescriptionInput = document.getElementById('modal-description');
const modalInitialResourcesGroup = document.getElementById('modal-initial-resources-group');
const modalInitialResourcesInput = document.getElementById('modal-initial-resources');

function showModal(type, uid = null) {
  modalForm.reset();
  modalItemType.value = type;
  modalEditUid.value = uid;

  let item = {};
  const isEditMode = uid !== null;
  const modeText = isEditMode ? '编辑' : '添加';

  if (isEditMode) {
    const globalData = type === 'talent' ? editorData.talents : editorData.backgrounds;
    item = globalData.find(d => String(d.uid) === String(uid)) || {};
  }
  modalEditIdentifier.value = item.name || ''; // Store original name for comparison

  modalTitle.textContent = `${modeText}${type === 'talent' ? '天赋' : '背景'}`;
  modalNameInput.value = item.name || '';
  modalAuthorInput.value = item.author || '';
  modalSeriesInput.value = item.series || '';
  modalDescriptionInput.value = item.description || '';
 if (type === 'talent') {
            modalCostGroup.style.display = 'block';
            modalInitialResourcesGroup.style.display = 'none';
            modalCostInput.value = item.cost || 0;
          } else {
            modalCostGroup.style.display = 'none';
            modalInitialResourcesGroup.style.display = 'block';
            modalInitialResourcesInput.value = (item.initialResources || []).join('\n');
          }
          modal.style.display = 'flex';
        }

        function hideModal() {
          modal.style.display = 'none';
        }

        async function saveModalData() {
          const type = modalItemType.value;
          const uid = modalEditUid.value || undefined;
          
          const name = modalNameInput.value.trim();
          const author = modalAuthorInput.value.trim();
          const series = modalSeriesInput.value.trim();
          const description = modalDescriptionInput.value.trim();

          if (!name || !author || !description) {
            await guiXuAlert('名称、作者和描述均为必填项。', '输入错误');
            return;
          }

          const newItemData = { uid, name, author, series, description };
          if (type === 'talent') {
            const cost = parseInt(modalCostInput.value, 10);
            if (isNaN(cost)) {
              await guiXuAlert('消耗点数必须是数字。', '输入错误');
              return;
            }
            newItemData.cost = cost;
          } else {
            newItemData.initialResources = modalInitialResourcesInput.value
                .split('\n').map(line => line.trim()).filter(line => line);
          }

          const targetArray = type === 'talent' ? editorData.talents : editorData.backgrounds;
          const existingItem = targetArray.find(item => item.name === name && String(item.uid) !== String(uid));
          if (existingItem) {
            await guiXuAlert(`名称 "${name}" 已被另一个条目占用，请使用其他名称。`, '输入错误');
            return;
          }

          document.getElementById('loading-overlay').style.display = 'flex';
          try {
            const success = await WorldBookManager.saveTalentOrBackground(newItemData, type);
            if (success) {
              await loadEditorData();
              hideModal();
            } else {
              await guiXuAlert('保存失败，请检查控制台错误信息。', '错误');
            }
          } catch (error) {
            console.error('保存时发生错误:', error);
            await guiXuAlert('保存失败：' + error.message, '错误');
          } finally {
            document.getElementById('loading-overlay').style.display = 'none';
          }
        }
        
        const wbModal = document.getElementById('worldbook-editor-modal');
        
        function setStrategyButtonState(strategy) {
            const btn = document.getElementById('wb-strategy-toggle-btn');
            if (strategy === 'constant') {
                btn.textContent = '策略: 常量 (蓝灯)';
                btn.className = 'editor-btn strategy-constant';
                btn.dataset.strategy = 'constant';
            } else {
                btn.textContent = '策略: 选择性 (绿灯)';
                btn.className = 'editor-btn strategy-selective';
                btn.dataset.strategy = 'selective';
            }
        }

        function showWorldBookModal(entry = null, presetContext = null) {
            const form = document.getElementById('wb-modal-form');
            form.reset();

            // Store preset context in hidden fields
            document.getElementById('wb-modal-preset-series').value = presetContext?.series || '';
            document.getElementById('wb-modal-preset-author').value = presetContext?.author || '';

            if (entry) {
                document.getElementById('wb-modal-title').textContent = '编辑世界书条目';
                document.getElementById('wb-modal-edit-uid').value = entry.uid;
                document.getElementById('wb-modal-comment').value = entry.name;
                document.getElementById('wb-modal-content').value = entry.content;
                document.getElementById('wb-modal-enabled').checked = entry.enabled;
                setStrategyButtonState(entry.strategy?.type || 'constant');
                document.getElementById('wb-modal-keys').value = (entry.strategy?.keys || []).join(', ');
                document.getElementById('wb-position-type').value = entry.position?.type || 'before_character_definition';
                document.getElementById('wb-position-order').value = entry.position?.order ?? 100;
                document.getElementById('wb-position-depth').value = entry.position?.depth ?? 0;
                document.getElementById('wb-position-role').value = entry.position?.role || 'system';
                document.getElementById('wb-recursion-incoming').checked = entry.recursion?.prevent_incoming || false;
                document.getElementById('wb-recursion-outgoing').checked = entry.recursion?.prevent_outgoing || false;
            } else {
                const title = presetContext ? `为【${presetContext.series}】系列创建新条目` : '添加新世界书条目';
                document.getElementById('wb-modal-title').textContent = title;
                document.getElementById('wb-modal-edit-uid').value = '';
                setStrategyButtonState('constant'); // Default for new entries
            }
            
            const positionTypeSelect = document.getElementById('wb-position-type');
            const depthSettings = document.getElementById('wb-depth-settings');
            depthSettings.style.display = positionTypeSelect.value === 'at_depth' ? 'grid' : 'none';

            wbModal.style.display = 'flex';
        }
        
        function hideWorldBookModal() {
            wbModal.style.display = 'none';
        }

        async function saveWorldBookData() {
            const uid = document.getElementById('wb-modal-edit-uid').value || null;
            let name = document.getElementById('wb-modal-comment').value.trim();
            const content = document.getElementById('wb-modal-content').value.trim();

            const presetSeries = document.getElementById('wb-modal-preset-series').value;
            const presetAuthor = document.getElementById('wb-modal-preset-author').value;

            if (!name) {
                await guiXuAlert('标题不能为空。', '输入错误');
                return;
            }
            
            // If creating a preset-specific entry, construct the full name
            if (presetSeries && presetAuthor && !uid) { // Only format new entries
                name = `【世界书】【${presetSeries}】【${presetAuthor}】${name}`;
            } else if (!name.startsWith('【')) {
                // For regular entries, enforce the prefix if not present
                name = `【世界书】${name}`;
            }

            const isReserved = [...editorData.talents, ...editorData.backgrounds, ...editorData.presets]
                .some(item => item.originalComment === name && String(item.uid) !== String(uid));
            if (isReserved && !name.startsWith('【世界书】')) {
                await guiXuAlert('该标题已被天赋/背景/预设编辑器占用，请使用其他标题，或使用【世界书】前缀。', '标题冲突');
                return;
            }

            document.getElementById('loading-overlay').style.display = 'flex';
            try {
                const entryData = {
                    uid,
                    name,
                    content,
                    enabled: document.getElementById('wb-modal-enabled').checked,
                    strategy: {
                        type: document.getElementById('wb-strategy-toggle-btn').dataset.strategy,
                        keys: document.getElementById('wb-modal-keys').value.split(',').map(k => k.trim()).filter(Boolean),
                    },
                    position: {
                        type: document.getElementById('wb-position-type').value,
                        order: parseInt(document.getElementById('wb-position-order').value, 10) || 100,
                        depth: parseInt(document.getElementById('wb-position-depth').value, 10) || 0,
                        role: document.getElementById('wb-position-role').value,
                    },
                    probability: 100, // Default to 100% as per request
                    recursion: {
                        prevent_incoming: document.getElementById('wb-recursion-incoming').checked,
                        prevent_outgoing: document.getElementById('wb-recursion-outgoing').checked,
                        delay_until: null,
                    },
                    effect: { sticky: null, cooldown: null, delay: null }
                };

                const success = await WorldBookManager.saveWorldBookEntry(entryData);
                if (success) {
                    await loadEditorData();
                    hideWorldBookModal();
                } else {
                    await guiXuAlert('保存世界书条目失败。', '错误');
                }
            } catch (error) {
                console.error('保存世界书条目时出错:', error);
                await guiXuAlert('保存失败: ' + error.message, '错误');
            } finally {
                document.getElementById('loading-overlay').style.display = 'none';
            }
        }


        // --- 预设编辑器逻辑 ---
        function renderPresetDetails(preset) {
          const detailsPanel = document.getElementById('preset-details-panel');
          const controlsContainer = document.getElementById('preset-controls-container');
          const collapsibleArea = document.getElementById('preset-details-collapsible-area');

          if (!detailsPanel || !controlsContainer || !collapsibleArea) return;

          if (!preset) {
            if (window.innerWidth > 768) {
              detailsPanel.style.display = 'none';
            }
            return;
          }
          if (window.innerWidth > 768) {
            detailsPanel.style.display = 'block';
          }

          document.getElementById('preset-name').value = preset.name || '';
          document.getElementById('preset-author').value = preset.author || '';
          document.getElementById('preset-series').value = preset.series || '';
          document.getElementById('preset-points').value = preset.points || 0;

          controlsContainer.innerHTML = `
            <div class="preset-controls">
              <button type="button" id="toggle-preset-details-btn" class="preset-toggle-icon-btn" title="收拢/展开配置">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
              </button>
              <div style="display: flex; align-items: center; gap: 8px;">
                <input type="checkbox" id="preset-worldbook-enabled-switch" data-uid="${preset.uid}" ${preset.enabled ? 'checked' : ''} style="width: 18px; height: 18px; cursor: pointer;">
                <label for="preset-worldbook-enabled-switch" style="color: #c9aa71; cursor: pointer;">启用世界书</label>
              </div>
            </div>`;
          collapsibleArea.style.display = 'block';
          document.getElementById('toggle-preset-details-btn').classList.remove('collapsed');

          renderPresetAttributes(preset.attributes || {});
          renderPresetTalentSelectors(preset);
          renderPresetSeriesContent(preset);
        }

        function renderPresetAttributes(presetAttributes) {
          const attributesGrid = document.getElementById('preset-attributes-grid');
          if (!attributesGrid) return;
          attributesGrid.innerHTML = '';
          Object.entries(GAME_DATA.attributes).forEach(([id, attr]) => {
            const spentValue = presetAttributes[id] || 0;
            const finalValue = spentValue + (baseAttributes[id] || 0);
            const card = document.createElement('div');
            card.className = 'attribute-card';
            card.innerHTML = `
              <div class="attribute-header">
                <span class="attribute-name">${attr.name}</span>
                <div class="attribute-value">
                  <button type="button" class="value-btn decrease-btn" data-attribute="${id}" ${spentValue <= 0 ? 'disabled' : ''}>-</button>
                  <span class="value">${finalValue}</span>
                  <button type="button" class="value-btn increase-btn" data-attribute="${id}">+</button>
                </div>
              </div>
            `;
            attributesGrid.appendChild(card);
          });
        }

        function addTalentToPreset(talentName) {
          if (!currentEditingPreset) return;
          if (!currentEditingPreset.optionalTalents) currentEditingPreset.optionalTalents = [];
          const allSelected = new Set([...(currentEditingPreset.requiredTalents || []), ...(currentEditingPreset.optionalTalents || [])]);
          if (allSelected.has(talentName)) return;
          currentEditingPreset.optionalTalents.push(talentName);
          renderPresetTalentSelectors(currentEditingPreset);
        }

        function setTalentStateInPreset(talentName, state) {
          if (!currentEditingPreset) return;
          const required = new Set(currentEditingPreset.requiredTalents || []);
          const optional = new Set(currentEditingPreset.optionalTalents || []);
          if (state === 'required') {
            optional.delete(talentName);
            required.add(talentName);
          } else {
            required.delete(talentName);
            optional.add(talentName);
          }
          currentEditingPreset.requiredTalents = Array.from(required);
          currentEditingPreset.optionalTalents = Array.from(optional);
          renderPresetTalentSelectors(currentEditingPreset);
        }

        function removeTalentFromPreset(talentName) {
          if (!currentEditingPreset) return;
          const required = new Set(currentEditingPreset.requiredTalents || []);
          const optional = new Set(currentEditingPreset.optionalTalents || []);
          required.delete(talentName);
          optional.delete(talentName);
          currentEditingPreset.requiredTalents = Array.from(required);
          currentEditingPreset.optionalTalents = Array.from(optional);
          renderPresetTalentSelectors(currentEditingPreset);
        }

        function renderPresetTalentSelectors(preset) {
          const availableList = document.getElementById('available-talents-list');
          const selectedList = document.getElementById('selected-talents-list');
          if (!availableList || !selectedList) return;
          availableList.innerHTML = '';
          selectedList.innerHTML = '';
          if (!preset) return;

          const requiredIds = new Set(preset.requiredTalents || []);
          const optionalIds = new Set(preset.optionalTalents || []);
          const allSelectedIds = new Set([...requiredIds, ...optionalIds]);
          const presetSeries = (preset.series || '').trim();

          editorData.talents.forEach(talent => {
            if (!allSelectedIds.has(talent.name)) {
              const talentEl = document.createElement('div');
              const seriesString = String(talent.series || '').trim();
              const seriesInfo = seriesString ? `[${seriesString}] ` : '';
              talentEl.textContent = `${seriesInfo}${talent.name} (${talent.cost || 0}点)`;
              talentEl.classList.add('editor-item');
              talentEl.style.cursor = 'pointer';
              talentEl.style.padding = '8px';
              talentEl.dataset.talentName = talent.name;
              const talentSeries = (talent.series || '').trim();
              if (talentSeries && talentSeries !== presetSeries) {
                  talentEl.classList.add('disabled');
                  talentEl.title = `这是【${talentSeries}】系列的专属天赋，无法选择。`;
              }
              availableList.appendChild(talentEl);
            }
          });

          const renderSelected = talentName => {
            const talent = editorData.talents.find(t => t.name === talentName);
            if (!talent) return;
            const isRequired = requiredIds.has(talent.name);
            const talentEl = document.createElement('div');
            talentEl.classList.add('selected-talent-item');
            talentEl.dataset.talentName = talent.name;
            const seriesString = String(talent.series || '').trim();
            const seriesInfo = seriesString ? `[${seriesString}] ` : '';
            let actionsHtml = isRequired ? `
                <span class="tag required-tag">必选</span>
                <button class="preset-talent-action-btn" data-action="setOptional">设为可选</button>
                <button class="preset-talent-action-btn" data-action="remove">移除</button>
              ` : `
                <span class="tag optional-tag">可选</span>
                <button class="preset-talent-action-btn" data-action="setRequired">设为必选</button>
                <button class="preset-talent-action-btn" data-action="remove">移除</button>
              `;
            talentEl.innerHTML = `
              <span class="selected-talent-name">${seriesInfo}${talent.name} (${talent.cost || 0}点)</span>
              <div class="talent-preset-actions">${actionsHtml}</div>`;
            selectedList.appendChild(talentEl);
          };
          (preset.requiredTalents || []).sort().forEach(renderSelected);
          (preset.optionalTalents || []).sort().forEach(renderSelected);
        }

        function switchPresetTab(tabName) {
          document.querySelectorAll('.preset-tab-btn').forEach(btn => btn.classList.remove('active'));
          document.querySelectorAll('.preset-tab-content').forEach(content => content.classList.remove('active'));
          const clickedBtn = document.querySelector(`.preset-tab-btn[data-tab="${tabName}"]`);
          if (clickedBtn) clickedBtn.classList.add('active');
          const targetContentId = tabName === 'talents' ? 'talents-tab-content' : tabName + '-tab';
          const targetContent = document.getElementById(targetContentId);
          if (targetContent) targetContent.classList.add('active');
        }

        function renderPresetSeriesContent(preset) {
            const seriesContainer = document.getElementById('preset-series-content');
            if (!seriesContainer) return;
            const seriesName = (preset.series || '').trim();
            const presetAuthor = (preset.author || '').trim();

            if (!seriesName) {
                seriesContainer.innerHTML = '<p style="color: #888; text-align: center;">此预设未指定系列。请在基本信息中设置系列以查看关联内容。</p>';
                return;
            }

            const seriesData = SeriesManager.getSeriesData(seriesName);
            const seriesWorldbooks = editorData.worldbookEntries.filter(entry => {
                const titleInfo = WorldBookManager.parseCommentTitle(entry.name);
                return titleInfo.type === '世界书' && titleInfo.series === seriesName && titleInfo.author === presetAuthor;
            });

            let content = '';
            if (seriesData.talents.length > 0 || seriesData.backgrounds.length > 0 || seriesWorldbooks.length > 0) {
                content += `<div class="series-section"><h4>【${seriesName}】系列内容</h4>`;
                
                if (seriesData.talents.length > 0) {
                    content += `<div class="series-talents"><h5>系列天赋 (${seriesData.talents.length}个)</h5><div class="series-items">${seriesData.talents.map(talent => `<div class="series-item ${preset.requiredTalents?.includes(talent.name) ? 'required' : preset.optionalTalents?.includes(talent.name) ? 'optional' : ''}"><span class="item-name">${talent.name}</span><span class="item-cost">${talent.cost}点</span><span class="item-author">${talent.author}</span>${preset.requiredTalents?.includes(talent.name) ? '<span class="tag required-tag">必选</span>' : ''}${preset.optionalTalents?.includes(talent.name) ? '<span class="tag optional-tag">可选</span>' : ''}<div class="item-description-details">${talent.description || '暂无描述'}</div></div>`).join('')}</div></div>`;
                }

                if (seriesData.backgrounds.length > 0) {
                    content += `<div class="series-backgrounds"><h5>系列背景 (${seriesData.backgrounds.length}个)</h5><div class="series-items">${seriesData.backgrounds.map(bg => `<div class="series-item"><span class="item-name">${bg.name}</span><span class="item-author">${bg.author}</span><div class="item-description-details">${bg.description || '暂无描述'}</div></div>`).join('')}</div></div>`;
                }

                if (seriesWorldbooks.length > 0) {
                    content += `<div class="series-extensions"><h5>系列扩展 (${seriesWorldbooks.length}个)</h5><div class="series-items">${seriesWorldbooks.map(wb => {
                        const titleInfo = WorldBookManager.parseCommentTitle(wb.name);
                        return `<div class="series-item"><span class="item-name">${titleInfo.name}</span><span class="item-author">${titleInfo.author}</span><div class="item-description-details">${wb.content || '暂无描述'}</div></div>`;
                    }).join('')}</div></div>`;
                }

                content += `</div>`;
            }

            if (!content) {
                content = `<p style="color: #888; text-align: center;">未找到与【${seriesName}】系列关联的天赋、背景或扩展。</p>`;
            }
            seriesContainer.innerHTML = content;
        }

        async function saveCurrentPreset() {
          if (!currentEditingPreset) return Promise.reject(new Error('No preset selected'));
          const oldName = currentEditingPreset.name;
          const newName = document.getElementById('preset-name').value.trim();
          if (!newName) return Promise.reject(new Error('预设名称不能为空。'));
          if (oldName !== newName && editorData.presets.some(p => p.name === newName)) {
            return Promise.reject(new Error(`名称为 "${newName}" 的预设已存在。`));
          }
          currentEditingPreset.name = newName;
          currentEditingPreset.author = document.getElementById('preset-author').value.trim();
          currentEditingPreset.series = document.getElementById('preset-series').value.trim();
          currentEditingPreset.points = parseInt(document.getElementById('preset-points').value) || 40;
          currentEditingPreset.enabled = document.getElementById('preset-worldbook-enabled-switch').checked;
          await WorldBookManager.savePreset(currentEditingPreset);
          const worldBookData = await WorldBookManager.loadAllData();
          Object.assign(editorData, {
              talents: worldBookData.talents || [],
              backgrounds: worldBookData.backgrounds || [],
              presets: worldBookData.presets || [],
              worldbookEntries: worldBookData.worldbookEntries || [],
          });
          const newlySavedPreset = editorData.presets.find(p => p.name === currentEditingPreset.name);
          if (newlySavedPreset) {
            currentEditingPreset.uid = newlySavedPreset.uid;
            currentEditingPreset.originalComment = newlySavedPreset.originalComment;
          }
          renderPresetEditor();
        }

        async function duplicateCurrentPreset() {
          if (!currentEditingPreset) return;
          const newName = await guiXuPrompt('输入新预设的名称:', currentEditingPreset.name + '_副本', '复制预设');
          if (!newName || editorData.presets.some(p => p.name === newName)) {
            if (newName !== null) await guiXuAlert('名称无效或已存在。', '错误');
            return;
          }
          const newPreset = { ...JSON.parse(JSON.stringify(currentEditingPreset)), name: newName, id: newName, uid: undefined };
          document.getElementById('loading-overlay').style.display = 'flex';
          try {
            await WorldBookManager.savePreset(newPreset);
            await loadEditorData();
            editPreset(newPreset.name);
            await guiXuAlert('预设复制成功！');
          } catch (error) {
            console.error('复制预设失败:', error);
            await guiXuAlert('复制失败：' + error.message, '错误');
          } finally {
            document.getElementById('loading-overlay').style.display = 'none';
          }
        }

        async function deleteCurrentPreset() {
          if (!currentEditingPreset) return;
          if (!(await guiXuConfirm(`确定要删除预设 "${currentEditingPreset.name}" 吗？此操作不可撤销。`, '删除确认'))) return;
          document.getElementById('loading-overlay').style.display = 'flex';
          try {
            await WorldBookManager.deleteEntryByUid(currentEditingPreset.uid);
            await loadEditorData();
            currentEditingPreset = null;
            renderPresetDetails(null);
            await guiXuAlert('预设删除成功！');
          } catch (error) {
            console.error('删除预设失败:', error);
            await guiXuAlert('删除失败：' + error.message, '错误');
          } finally {
            document.getElementById('loading-overlay').style.display = 'none';
          }
        }

        function editPreset(name) {
          const preset = editorData.presets.find(p => p.name === name);
          if (preset) {
            currentEditingPreset = JSON.parse(JSON.stringify(preset));
            renderPresetEditor();
            renderPresetDetails(currentEditingPreset);
            switchPresetTab('attributes');
          }
        }
        
        async function promptPresetSelectionForWB() {
            const presetsWithSeries = editorData.presets.filter(p => (p.series || '').trim() && (p.author || '').trim());
            if (presetsWithSeries.length === 0) {
                await guiXuAlert('没有找到任何已设置“系列”和“作者”的预设。请先在预设编辑器中完善预设信息。', '无法创建');
                return;
            }

            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.style.cssText = 'display: flex; z-index: 2001;';
            let presetsHtml = presetsWithSeries.map(p => 
                `<div class="choice-item" data-preset-name="${p.name}">
                    <div class="choice-item-title">${p.name}</div>
                    <div class="choice-item-desc">系列: ${p.series} | 作者: ${p.author}</div>
                 </div>`
            ).join('');

            modal.innerHTML = `
              <div class="modal-content" style="width: 90%; max-width: 500px; height: auto;">
                <h2 class="modal-title">选择一个预设</h2>
                <div class="modal-body" style="padding: 20px; max-height: 60vh; overflow-y: auto;">
                  <p>请选择一个预设，新创建的世界书条目将自动关联其“系列”和“作者”。</p>
                  <div style="margin-top:20px;">${presetsHtml}</div>
                </div>
                <div class="modal-footer"><button class="editor-btn btn-danger" id="preset-select-cancel-btn">取消</button></div>
              </div>`;
            document.body.appendChild(modal);

            modal.addEventListener('click', (e) => {
                const choice = e.target.closest('.choice-item');
                if (choice) {
                    const presetName = choice.dataset.presetName;
                    const selectedPreset = presetsWithSeries.find(p => p.name === presetName);
                    if (selectedPreset) {
                        showWorldBookModal(null, { series: selectedPreset.series, author: selectedPreset.author });
                    }
                    modal.remove();
                } else if (e.target.id === 'preset-select-cancel-btn' || e.target === modal) {
                    modal.remove();
                }
            });
        }

        function setupEditorEventListeners() {
          const editorContainer = document.getElementById('editor-container');
          if (!editorContainer) return;
          
          wbModal.addEventListener('click', e => {
              if(e.target.id === 'wb-modal-save-btn') saveWorldBookData();
              if(e.target.id === 'wb-modal-cancel-btn') hideWorldBookModal();
              if(e.target.id === 'wb-strategy-toggle-btn') {
                  const current = e.target.dataset.strategy;
                  setStrategyButtonState(current === 'constant' ? 'selective' : 'constant');
              }
          });
          document.getElementById('wb-position-type').addEventListener('change', e => {
             document.getElementById('wb-depth-settings').style.display = e.target.value === 'at_depth' ? 'grid' : 'none';
          });
          
          // New listeners for search and refresh
          const searchInput = document.getElementById('wb-search-input');
          if (searchInput) {
              searchInput.addEventListener('input', () => {
                  renderWorldBookEditor();
              });
          }
          
          const refreshBtn = document.getElementById('wb-refresh-btn');
          if (refreshBtn) {
              refreshBtn.addEventListener('click', async () => {
                  await loadEditorData();
                  showSaveStatus('数据已刷新', true);
              });
          }

          editorContainer.addEventListener('click', async e => {
            const target = e.target;
            const tabButton = target.closest('.tab-button');
            if (tabButton) {
              document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
              tabButton.classList.add('active');
              document.querySelectorAll('.tab-pane').forEach(pane => pane.style.display = 'none');
              document.getElementById(tabButton.dataset.tab + '-tab').style.display = 'block';
              return;
            }

            if (target.id === 'add-new-talent-btn') return showModal('talent');
            if (target.id === 'add-new-background-btn') return showModal('background');
            const editTalentBtn = target.closest('.edit-talent-btn');
            if (editTalentBtn) return showModal('talent', editTalentBtn.dataset.uid);

            const deleteTalentBtn = target.closest('.delete-talent-btn');
            if (deleteTalentBtn) {
              const uid = deleteTalentBtn.dataset.uid;
              const name = deleteTalentBtn.dataset.name;
              if (uid && (await guiXuConfirm(`你确定要删除天赋 "${name}" 吗?`, '删除确认'))) {
                if (await WorldBookManager.deleteEntryByUid(uid)) {
                    await guiXuAlert(`天赋 "${name}" 已删除。`);
                    await loadEditorData();
                } else {
                    await guiXuAlert('删除失败', '错误');
                }
              }
              return;
            }

            const editBgBtn = target.closest('.edit-background-btn');
            if (editBgBtn) return showModal('background', editBgBtn.dataset.uid);

            const deleteBgBtn = target.closest('.delete-background-btn');
            if (deleteBgBtn) {
              const uid = deleteBgBtn.dataset.uid;
              const name = deleteBgBtn.dataset.name;
              if (uid && (await guiXuConfirm(`你确定要删除背景 "${name}" 吗?`, '删除确认'))) {
                if (await WorldBookManager.deleteEntryByUid(uid)) {
                    await guiXuAlert(`背景 "${name}" 已删除。`);
                    await loadEditorData();
                } else {
                    await guiXuAlert('删除失败', '错误');
                }
              }
              return;
            }
            
            const wbFilterBtn = target.closest('.wb-filter-btn');
            if (wbFilterBtn) {
                document.querySelectorAll('.wb-filter-btn').forEach(btn => btn.classList.remove('active'));
                wbFilterBtn.classList.add('active');
                currentWbFilter = wbFilterBtn.dataset.filter;
                renderWorldBookEditor();
                return;
            }

            if (target.id === 'add-new-worldbook-btn') return showWorldBookModal();
            if (target.id === 'add-preset-worldbook-btn') return promptPresetSelectionForWB();

            const wbItem = target.closest('.editor-item[data-uid]');
            if(wbItem) {
                const uid = wbItem.dataset.uid;
                const entry = editorData.worldbookEntries.find(e => String(e.uid) === String(uid));
                
                if (!entry) {
                    console.error(`[归墟编辑器] 错误：在数据中未找到 UID 为 ${uid} 的世界书条目。可能是数据不同步导致的。`);
                    await guiXuAlert('操作失败：找不到对应的世界书条目，数据可能已过期，请尝试点击“刷新数据”按钮。', '错误');
                    return;
                }
                
                if(target.closest('.edit-wb-btn')) return showWorldBookModal(entry);

                if(target.closest('.delete-wb-btn')) {
                    if (await guiXuConfirm(`确定要删除世界书条目 "${entry.name}" 吗？`)) {
                        await WorldBookManager.deleteEntryByUid(entry.uid);
                        await loadEditorData();
                    }
                    return;
                }
                
                if(target.closest('.toggle-wb-btn')) {
                    await TavernHelper.updateWorldbookWith(WorldBookManager.LOREBOOK_NAME, (worldbook) => {
                        const entryToUpdate = worldbook.find(e => String(e.uid) === String(uid));
                        if (entryToUpdate) entryToUpdate.enabled = !entryToUpdate.enabled;
                        return worldbook;
                    });
                    await loadEditorData();
                    return;
                }
            }

            const presetItem = target.closest('.preset-list-item');
            if (presetItem) {
              editPreset(presetItem.dataset.presetName);
              if (window.innerWidth <= 768) {
                document.querySelector('.preset-editor-layout').classList.add('mobile-details-view');
              }
              return;
            }

            if (target.id === 'add-new-preset-btn') {
                const newName = await guiXuPrompt('输入新预设的名称:', '', '新预设');
                if (newName && newName.trim() !== '') {
                    if (editorData.presets.some(p => p.name === newName.trim())) {
                        await guiXuAlert('该名称的预设已存在。', '错误');
                        return;
                    }
                    const newSeries = await guiXuPrompt('输入系列名称 (可留空):', '', '系列');
                    const newPreset = { id: newName.trim(), name: newName.trim(), author: '玩家', points: 40, attributes: {}, requiredTalents: [], optionalTalents: [], series: (newSeries || '').trim(), description: '', enabled: false };
                    await WorldBookManager.savePreset(newPreset);
                    await loadEditorData();
                    editPreset(newPreset.name);
                }
                return;
            }

            if (target.id === 'export-preset-btn') {
              if (!currentEditingPreset) return await guiXuAlert('请先从列表中选择一个预设。');
              exportSeriesPackage(currentEditingPreset);
              return;
            }

            const presetDetailsPanel = target.closest('#preset-details-panel');
            if (presetDetailsPanel) {
              if (target.id === 'preset-back-to-list-btn') {
                document.querySelector('.preset-editor-layout').classList.remove('mobile-details-view');
                currentEditingPreset = null;
                renderPresetEditor();
                return;
              }
              const toggleBtn = target.closest('#toggle-preset-details-btn');
              if (toggleBtn) {
                  const collapsibleArea = document.getElementById('preset-details-collapsible-area');
                  const isCollapsed = collapsibleArea.style.display === 'none';
                  collapsibleArea.style.display = isCollapsed ? 'block' : 'none';
                  toggleBtn.classList.toggle('collapsed', !isCollapsed);
                  return;
              }
              const presetTabBtn = target.closest('.preset-tab-btn');
              if (presetTabBtn) return switchPresetTab(presetTabBtn.dataset.tab);
              const attrBtn = target.closest('.attribute-card .value-btn');
              if (attrBtn && !attrBtn.disabled) {
                  const attrId = attrBtn.dataset.attribute;
                  if (!currentEditingPreset) return;
                  if (!currentEditingPreset.attributes) currentEditingPreset.attributes = {};
                  let currentValue = currentEditingPreset.attributes[attrId] || 0;
                  if (attrBtn.classList.contains('increase-btn')) currentValue++;
                  else if (attrBtn.classList.contains('decrease-btn') && currentValue > 0) currentValue--;
                  currentEditingPreset.attributes[attrId] = currentValue;
                  renderPresetAttributes(currentEditingPreset.attributes);
                  debouncedSave();
                  return;
              }
              const availableTalentItem = target.closest('#available-talents-list .editor-item');
              if (availableTalentItem) {
                if (availableTalentItem.classList.contains('disabled')) return await guiXuAlert(availableTalentItem.title);
                addTalentToPreset(availableTalentItem.dataset.talentName);
                debouncedSave();
                return;
              }
              const talentActionBtn = target.closest('.preset-talent-action-btn');
              if (talentActionBtn) {
                const talentName = talentActionBtn.closest('.selected-talent-item').dataset.talentName;
                const action = talentActionBtn.dataset.action;
                if (action === 'setRequired') setTalentStateInPreset(talentName, 'required');
                else if (action === 'setOptional') setTalentStateInPreset(talentName, 'optional');
                else if (action === 'remove') removeTalentFromPreset(talentName);
                debouncedSave();
                return;
              }
              const seriesItem = target.closest('.series-item');
              if (seriesItem) {
                const details = seriesItem.querySelector('.item-description-details');
                if (details) details.style.display = details.style.display === 'block' ? 'none' : 'block';
                return;
              }
              if (target.id === 'export-current-preset-btn') return exportSeriesPackage(currentEditingPreset);
              if (target.id === 'duplicate-current-preset-btn') return duplicateCurrentPreset();
              if (target.id === 'delete-current-preset-btn') return deleteCurrentPreset();
            }
          });

          editorContainer.addEventListener('change', e => {
            if (e.target.id === 'preset-worldbook-enabled-switch' && currentEditingPreset) {
              currentEditingPreset.enabled = e.target.checked;
              debouncedSave();
            }
          });
          editorContainer.addEventListener('input', e => {
            if (e.target.closest('#preset-name, #preset-author, #preset-series, #preset-points')) {
              debouncedSave();
            }
          });
        }

        async function importCustomTextData(text) {
            console.log('JSON parsing failed, attempting custom text import.');
            document.getElementById('loading-overlay').style.display = 'flex';
            let successCount = { talent: 0, background: 0, preset: 0 };
            let errorCount = 0;
            const entries = text.split(/^\s*#\s*comment:/gm).filter(s => s.trim() !== '');
            if (entries.length === 0) {
                document.getElementById('loading-overlay').style.display = 'none';
                throw new Error('未找到 "# comment:" 分隔的有效条目。');
            }
            for (const entryText of entries) {
                try {
                    const lines = entryText.trim().split('\n');
                    const commentLine = lines.shift().trim();
                    const content = lines.join('\n');
                    const comment = commentLine.replace(/\"/g, '');
                    const titleInfo = WorldBookManager.parseCommentTitle(comment);
                    const yamlData = YAMLParser.parse(content);
                    if (!titleInfo.type || !titleInfo.name) {
                        console.warn('Skipping entry with invalid comment:', comment);
                        errorCount++;
                        continue;
                    }
                    let dataToSave = {}, saveFunction, typeKey;
                    switch (titleInfo.type) {
                        case '天赋':
                            dataToSave = { name: titleInfo.name, author: titleInfo.author, series: titleInfo.series || yamlData.系列 || '', cost: parseInt(yamlData['消耗点数']) || 0, description: yamlData['描述'] || '' };
                            saveFunction = (data) => WorldBookManager.saveTalentOrBackground(data, 'talent'); typeKey = 'talent'; break;
                        case '背景':
                            dataToSave = { name: titleInfo.name, author: titleInfo.author, series: titleInfo.series || yamlData.系列 || '', description: yamlData['描述'] || '', initialResources: yamlData['初始资源'] || [] };
                            saveFunction = (data) => WorldBookManager.saveTalentOrBackground(data, 'background'); typeKey = 'background'; break;
                        case '预设':
                            dataToSave = { name: titleInfo.name, author: titleInfo.author, series: titleInfo.series || yamlData.系列 || '', points: parseInt(yamlData['点数']) || 40, description: yamlData['描述'] || '', attributes: yamlData['属性分配'] || {}, requiredTalents: yamlData['必选天赋'] || [], optionalTalents: yamlData['可选天赋'] || [] };
                            saveFunction = WorldBookManager.savePreset; typeKey = 'preset'; break;
                        default: console.warn('Unknown entry type:', titleInfo.type); errorCount++; continue;
                    }
                    if (await saveFunction(dataToSave, dataToSave.name)) successCount[typeKey]++;
                    else errorCount++;
                } catch (e) {
                    console.error('Error parsing custom text entry:', e, entryText);
                    errorCount++;
                }
            }
            await loadEditorData();
            document.getElementById('loading-overlay').style.display = 'none';
            await guiXuAlert(`自定义文本导入完成。\n\n成功导入:\n- 天赋: ${successCount.talent}个\n- 背景: ${successCount.background}个\n- 预设: ${successCount.preset}个\n\n失败: ${errorCount}个\n(详情请查看控制台)`);
        }
        
        async function exportSeriesPackage(preset) {
            if (!preset) return await guiXuAlert('没有选择任何预设。');
            const author = (preset.author || '').trim();
            const series = (preset.series || '').trim();
            if (!author || !series) return await guiXuAlert('无法导出系列包：预设的“作者”和“系列”字段必须都填写完整。');
            
            document.getElementById('loading-overlay').style.display = 'flex';
            try {
                const allEntries = await TavernHelper.getWorldbook(WorldBookManager.LOREBOOK_NAME);
                const authorTag = `【${author}】`;
                const seriesTag = `【${series}】`;
                const seriesEntries = allEntries.filter(entry => entry.name.includes(authorTag) && entry.name.includes(seriesTag));

                if (seriesEntries.length === 0) {
                    await guiXuAlert(`未找到任何同时包含“${authorTag}”和“${seriesTag}”的世界书条目，无法导出系列包。`);
                    return;
                }
                const seriesPackage = { type: 'GuixuSeriesPackage', version: '2.5', author, series, exportTime: new Date().toISOString(), entries: seriesEntries };
                exportData(JSON.stringify(seriesPackage, null, 2), `归墟系列包_${author}_${series}.json`);
                await guiXuAlert(`系列包 “${series}” (作者: ${author}) 导出成功，共包含 ${seriesEntries.length} 个条目！`);
            } catch (error) {
                console.error('导出系列包失败:', error);
                await guiXuAlert('导出系列包失败：' + error.message, '错误');
            } finally {
                document.getElementById('loading-overlay').style.display = 'none';
            }
        }
        
        async function importSeriesPackage(packageData) {
            if (!packageData || packageData.type !== 'GuixuSeriesPackage') throw new Error('文件不是有效的归墟系列包格式。');
            const entryCount = packageData.entries?.length || 0;
            if (entryCount === 0) return await guiXuAlert('此系列包不包含任何条目，无需导入。');
            if (!(await guiXuConfirm(`即将导入系列包 “${packageData.series}” (作者: ${packageData.author})，共 ${entryCount} 个条目。这将覆盖世界书中同名的条目。是否继续？`))) return;

            document.getElementById('loading-overlay').style.display = 'flex';
            try {
                const bookName = WorldBookManager.LOREBOOK_NAME;
                let createdCount = 0;
                let updatedCount = 0;

                await TavernHelper.updateWorldbookWith(bookName, (worldbook) => {
                    const existingComments = new Map(worldbook.map(e => [e.name, e]));
                    for (const entry of packageData.entries) {
                        const { uid, ...newEntryData } = entry;
                        if (existingComments.has(entry.name)) {
                            const existing = existingComments.get(entry.name);
                            Object.assign(existing, newEntryData);
                            updatedCount++;
                        } else {
                            worldbook.push(newEntryData);
                            createdCount++;
                        }
                    }
                    return worldbook;
                });

                await loadEditorData();
                await guiXuAlert(`系列包 “${packageData.series}” 导入成功！\n创建了 ${createdCount} 个新条目，更新了 ${updatedCount} 个现有条目。`);
            }  catch (error) {
                 console.error('导入系列包时出错:', error);
                 await guiXuAlert('导入系列包失败：' + error.message, '错误');
            } finally {
                 document.getElementById('loading-overlay').style.display = 'none';
            }
        }
        
        async function handleImportFile(fileContent) {
            try {
                const importedData = JSON.parse(fileContent);
                if (importedData.type === 'GuixuSeriesPackage') {
                    await importSeriesPackage(importedData);
                } else if (importedData.talents || importedData.backgrounds || importedData.presets) {
                    if (await guiXuConfirm("这是一个旧版的完整配置文件，导入将覆盖所有同名天赋、背景和预设。是否继续？")) {
                        document.getElementById('loading-overlay').style.display = 'flex';
                        for (const talent of importedData.talents || []) await WorldBookManager.saveTalentOrBackground(talent, 'talent');
                        for (const bg of importedData.backgrounds || []) await WorldBookManager.saveTalentOrBackground(bg, 'background');
                        for (const preset of importedData.presets || []) await WorldBookManager.savePreset(preset);
                        await loadEditorData();
                        await guiXuAlert("完整配置导入成功！");
                    }
                } else {
                    if (await guiXuConfirm("文件看起来像一个旧版的单独预设，是否要导入它？")) {
                        document.getElementById('loading-overlay').style.display = 'flex';
                        await WorldBookManager.savePreset(importedData);
                        await loadEditorData();
                        await guiXuAlert("单个预设导入成功！");
                    }
                }
            } catch (jsonError) {
                try {
                    await importCustomTextData(fileContent);
                } catch (customError) {
                    await guiXuAlert(`导入失败：文件既不是有效的JSON格式，也不是可识别的自定义文本格式。\n\nJSON错误: ${jsonError.message}\n自定义文本错误: ${customError.message}`, '导入失败');
                }
            } finally {
                document.getElementById('loading-overlay').style.display = 'none';
            }
        }

        function setupGlobalControls() {
            const importFileInput = document.getElementById('import-file-input');
            document.getElementById('import-all-btn').addEventListener('click', () => importFileInput.click());
            document.getElementById('import-preset-btn').addEventListener('click', () => importFileInput.click());
            importFileInput.addEventListener('change', event => {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = e => handleImportFile(e.target.result);
                reader.readAsText(file);
                importFileInput.value = '';
            });
            document.getElementById('export-all-btn').addEventListener('click', async () => {
                const dataToExport = { talents: editorData.talents, backgrounds: editorData.backgrounds, presets: editorData.presets };
                exportData(JSON.stringify(dataToExport, null, 2), 'guixu_full_config_backup.json');
                await guiXuAlert('所有配置导出成功！这是一个简单的本地备份，分享请使用系列包。');
            });
            document.getElementById('reset-editor-btn').addEventListener('click', resetEditorToDefaults);
        }

        function exportData(dataStr, fileName) {
            const link = document.createElement('a');
            link.href = URL.createObjectURL(new Blob([dataStr], { type: 'application/json' }));
            link.download = fileName;
            link.click();
            setTimeout(() => URL.revokeObjectURL(link.href), 100);
        }

        function renderAllEditors() {
            renderTalentEditor();
            renderBackgroundEditor();
            renderWorldBookEditor();
            renderPresetEditor();
            renderPresetDetails(currentEditingPreset);
            document.querySelector('.preset-editor-layout').classList.remove('mobile-details-view');
        }

        const mainViews = ['main-page-content', 'editor-container', 'setup-form', 'startup-choice-container'];
        async function showView(viewId) {
            mainViews.forEach(id => document.getElementById(id).style.display = 'none');
            const targetView = document.getElementById(viewId);
            if (targetView) targetView.style.display = (viewId === 'setup-form' || viewId === 'editor-modal') ? 'flex' : 'block';
            if (viewId === 'editor-container') await loadEditorData();
            if (window.ensureBackgroundImage) window.ensureBackgroundImage();
        }
        
    // --- START OF SAVE/LOAD MANAGER LOGIC ---
    function _getDisplayText(aiResponse) {
        try {
            if (!aiResponse || typeof aiResponse !== 'string') return '';
            const gameTextMatch = /<gametxt>([\s\S]*?)<\/gametxt>/i.exec(aiResponse);
            if (gameTextMatch && gameTextMatch[1]) {
                return gameTextMatch[1].replace(/<!--[\s\S]*?-->/g, '').trim();
            }
            return aiResponse.replace(/<\/?(本世历程|往世涟漪|UpdateVariable|角色提取|thinking|gametxt|开局设定|行动选项|action)[\s\S]*?>/gi, '').trim();
        } catch (e) {
            console.error("解析显示文本时出错:", e);
            return "[摘要解析失败]";
        }
    }

    async function getSavesFromStorage() {
        try {
            const bookName = WorldBookManager.LOREBOOK_NAME;
            const entries = await TavernHelper.getWorldbook(bookName);
            const map = {};
            if (!entries) return map;

            entries.forEach(e => {
                const name = String(e.name || '');
                if (name.startsWith('存档:')) {
                    const slotId = name.slice(3); // Remove '存档:' prefix
                    try {
                        map[slotId] = JSON.parse(e.content || '{}');
                    } catch (err) {
                        console.warn(`Failed to parse save data for slot ${slotId}:`, err);
                    }
                }
            });
            return map;
        } catch (e) {
            console.error("获取存档失败 (世界书):", e);
            await guiXuAlert('错误：无法从世界书读取存档。', '错误');
            return {};
        }
    }

    async function showSaveLoadManager() {
        const modal = document.getElementById('save-load-modal');
        const container = modal.querySelector('.modal-body');
        if (!modal || !container) return;

        modal.style.display = 'flex';
        const saves = await getSavesFromStorage();

        let autoHtml = `<h3 style="font-size: 14px; color: #8b7355; margin-bottom: 10px;">自动存档</h3>`;
        const autoSlotIds = ['auto_save_slot_0', 'auto_save_slot_1'];
        let hasAutoSaves = false;
        autoSlotIds.forEach(slotId => {
            if (saves[slotId]) hasAutoSaves = true;
            autoHtml += renderSlot(saves[slotId], slotId, true);
        });
        if (!hasAutoSaves) autoHtml += `<p style="text-align:center; color:#8b7355; font-size:12px; font-style: italic;">暂无自动存档。</p>`;

        let manualHtml = `<h3 style="font-size: 14px; color: #8b7355; margin-top: 20px; margin-bottom: 10px; border-top: 1px solid rgba(201, 170, 113, 0.3); padding-top: 15px;">手动存档</h3>`;
        let hasManualSaves = false;
        for (let i = 1; i <= 5; i++) {
            const slotId = `slot_${i}`;
            if (saves[slotId]) hasManualSaves = true;
            manualHtml += renderSlot(saves[slotId], slotId, false);
        }
        if (!hasManualSaves) manualHtml += `<p style="text-align:center; color:#8b7355; font-size:12px; font-style: italic;">暂无手动存档。</p>`;
        
        container.innerHTML = autoHtml + manualHtml;
    }

    function renderSlot(saveData, slotId, isAutoSave) {
        const actionsHtml = `
            <div class="save-slot-actions">
                <button class="theme-btn theme-btn-gold btn-small" data-action="load-slot" ${!saveData ? 'disabled' : ''}>读档</button>
                <button class="theme-btn theme-btn-gold btn-small" data-action="export-slot" ${!saveData ? 'disabled' : ''}>导出</button>
                <button class="theme-btn theme-btn-red btn-small" data-action="delete-slot" ${!saveData ? 'disabled' : ''}>删除</button>
            </div>`;

        let contentHtml;
        const statData = saveData?.mvu_data?.stat_data || saveData?.mvu_data;
        let defaultName = isAutoSave ? (slotId === 'auto_save_slot_0' ? '最新自动存档' : '上一次自动存档') : `存档 ${slotId.split('_')[1]}`;

        if (statData) {
            const saveName = saveData.save_name || defaultName;
            const date = new Date(saveData.timestamp).toLocaleString('zh-CN');
            const jingjie = statData['当前境界']?.[0] || '未知';
            const jinian = statData['当前时间纪年']?.[0] || '未知';
            const summary = _getDisplayText(saveData.message_content);
            contentHtml = `
                <div class="slot-name">${saveName}</div>
                ${actionsHtml}
                <div class="slot-time">${date} - ${jingjie} - ${jinian}</div>
                <div class="slot-summary">${summary ? summary.substring(0, 40) + '...' : '无正文记录'}</div>`;
        } else {
            contentHtml = `
                <div class="slot-name">${defaultName}</div>
                ${actionsHtml}
                <div class="slot-time" style="font-style: italic; color: #8b7355;">空存档位</div>`;
        }
        return `<div class="save-slot" data-slot-id="${slotId}"><div class="save-slot-info">${contentHtml}</div></div>`;
    }
    
    async function loadGame(slotId) {
        const allSaves = await getSavesFromStorage();
        const saveData = allSaves[slotId];
        if (!saveData) return;

        const saveName = saveData.save_name || slotId;
        if (!(await guiXuConfirm(`确定要读取存档“${saveName}”吗？当前所有未保存的进度将会被覆盖。`))) return;

        const loadingOverlay = document.getElementById('loading-overlay');
        loadingOverlay.innerHTML = `<p>正在读取“${saveName}”的记忆...</p>`;
        loadingOverlay.style.display = 'flex';

        try {
            const messages = await getChatMessages(0);
            if (!messages || !messages.length === 0) throw new Error("无法获取第0层消息，无法读档。");

            const messageZero = messages[0];
            messageZero.data = saveData.mvu_data;
            messageZero.message = saveData.message_content || '';

            // --- 新增：从独立世界书恢复到当前序号 ---
            if (saveData.lorebook_entries) {
                const entries = saveData.lorebook_entries;
                const bookName = WorldBookManager.LOREBOOK_NAME;
                const unifiedIndexInput = document.getElementById('unified-index-input');
                const currentIndex = unifiedIndexInput ? parseInt(unifiedIndexInput.value, 10) : 1;

                const currentJourneyKey = currentIndex > 1 ? `本世历程(${currentIndex})` : '本世历程';
                const currentPastLivesKey = currentIndex > 1 ? `往世涟漪(${currentIndex})` : '往世涟漪';
                const currentNovelModeKey = currentIndex > 1 ? `小说模式(${currentIndex})` : '小说模式'; // 简化处理

                await TavernHelper.updateWorldbookWith(bookName, async (allEntries) => {
                    const findOrCreate = (targetKey, sourceKey, baseKey, order) => {
                        const sourceEntry = allEntries.find(e => e.name === entries[sourceKey]);
                        const targetEntry = allEntries.find(e => e.name === targetKey);
                        if (sourceEntry) {
                            if (targetEntry) {
                                targetEntry.content = sourceEntry.content || '';
                            } else {
                                const base = allEntries.find(e => e.name === baseKey) || {};
                                allEntries.push({ ...base, uid: undefined, name: targetKey, content: sourceEntry.content || '', strategy: { ...base.strategy, keys: [...(base.strategy?.keys || []), targetKey] }, enabled: true, position: { ...base.position, order } });
                            }
                        }
                    };
                    findOrCreate(currentJourneyKey, 'journey_entry_name', '本世历程', 20);
                    findOrCreate(currentPastLivesKey, 'past_lives_entry_name', '往世涟漪', 19);
                    findOrCreate(currentNovelModeKey, 'novel_mode_entry_name', '小说模式', 18);
                    
                    return allEntries;
                });
                console.log(`[归墟读档] 已将存档"${saveName}"的世界书数据覆写到当前序号 ${currentIndex}`);
            }

            await TavernHelper.setChatMessages([messageZero], { refresh: 'all' });
            await guiXuAlert('读档成功！页面将刷新以应用所有更改。');
            window.location.reload();

        } catch (error) {
            console.error('读档失败:', error);
            await guiXuAlert(`读档失败: ${error.message}`, '错误');
        } finally {
            loadingOverlay.style.display = 'none';
        }
    }

    async function deleteWorldLoreForIndex(index) {
        try {
            const bookName = WorldBookManager.LOREBOOK_NAME;
            const allEntries = await TavernHelper.getWorldbook(bookName);
            if (!allEntries) return;

            const journeyBase = '本世历程';
            const pastLivesBase = '往世涟漪';
            
            const targetJourney = index > 1 ? `${journeyBase}(${index})` : journeyBase;
            const targetPastLives = index > 1 ? `${pastLivesBase}(${index})` : pastLivesBase;

            const uidsToDelete = allEntries
                .filter(e => e.name === targetJourney || e.name === targetPastLives)
                .map(e => e.uid);

            if (uidsToDelete.length > 0) {
                await TavernHelper.updateWorldbookWith(bookName, worldbook => {
                    return worldbook.filter(e => !uidsToDelete.includes(e.uid));
                });
                console.log(`[归墟删除] 已清除世界序号 ${index} 的激活条目，共 ${uidsToDelete.length} 条。`);
            }
        } catch (error) {
            console.error(`删除世界序号 ${index} 的世界书条目时出错:`, error);
            await guiXuAlert('警告：删除世界书激活条目失败。');
        }
    }

    async function deleteSave(slotId) {
        const allSaves = await getSavesFromStorage();
        const saveDataToDelete = allSaves[slotId];
        if (!saveDataToDelete) return;

        const slotName = saveDataToDelete.save_name || `存档${slotId.replace(/slot_|auto_save_slot_/, '')}`;
        let confirmMsg = `确定要删除存档 "${slotName}" 吗？此操作不可恢复。`;
        if (saveDataToDelete.lorebook_entries) {
            confirmMsg += `\n相关的世界书快照和激活条目也会被一并删除。`;
        }
        
        if (await guiXuConfirm(confirmMsg)) {
            try {
                const bookName = WorldBookManager.LOREBOOK_NAME;
                // Delete lorebook backups
                if (saveDataToDelete.lorebook_entries) {
                    const entryNamesToDelete = Object.values(saveDataToDelete.lorebook_entries);
                    await TavernHelper.updateWorldbookWith(bookName, (worldbook) => {
                        return worldbook.filter(e => !entryNamesToDelete.includes(e.name));
                    });
                }

                // NEW: Delete active lore entries for the corresponding world index
                const worldIndex = saveDataToDelete.unified_index || 1;
                await deleteWorldLoreForIndex(worldIndex);

                // Delete the save entry itself
                const saveEntryName = `存档:${slotId}`;
                await TavernHelper.updateWorldbookWith(bookName, (worldbook) => {
                    return worldbook.filter(e => e.name !== saveEntryName);
                });

                await guiXuAlert(`"${slotName}" 已删除。`);
                showSaveLoadManager();
            } catch (error) {
                console.error('删除存档失败:', error);
                await guiXuAlert(`删除存档失败: ${error.message}`, '错误');
            }
        }
    }
    
    async function clearAllSaves() {
        const allSaves = await getSavesFromStorage();
        const saveKeys = Object.keys(allSaves);
        const bookName = WorldBookManager.LOREBOOK_NAME;

        if (saveKeys.length === 0) {
            try {
                const allLoreEntries = await TavernHelper.getWorldbook(bookName);
                if (!allLoreEntries) {
                    await guiXuAlert("没有可清除的存档数据。");
                    return;
                }

                const journeyBase = '本世历程';
                const pastLivesBase = '往世涟漪';
                const activeLoreEntries = allLoreEntries.filter(e => {
                    const name = String(e.name || "");
                    return name === journeyBase || name.startsWith(journeyBase + "(") || name === pastLivesBase || name.startsWith(pastLivesBase + "(");
                });

                if (activeLoreEntries.length > 0) {
                    const indices = new Set();
                    activeLoreEntries.forEach(e => {
                        const name = String(e.name || "");
                        let idx = 1;
                        const m = name.match(/\((\d+)\)$/);
                        if (m) idx = parseInt(m[1], 10);
                        indices.add(idx);
                    });

                    const idxList = Array.from(indices).sort((a, b) => a - b).join(", ");
                    const msg = `未发现任何存档记录，但检测到世界书中存在 ${activeLoreEntries.length} 条“本世历程/往世涟漪”激活条目（涉及世界序号：${idxList}）。\n是否清理这些激活条目？此操作不可恢复。`;

                    if (await guiXuConfirm(msg, "高危操作确认")) {
                        document.getElementById('loading-overlay').style.display = 'flex';
                        try {
                            for (const idx of indices) {
                                await deleteWorldLoreForIndex(idx);
                            }
                            await guiXuAlert("已清理检测到的激活条目。");
                            showSaveLoadManager();
                        } catch (e) {
                            console.error("清理激活条目失败:", e);
                            await guiXuAlert(`清理失败: ${e.message}`, '错误');
                        } finally {
                            document.getElementById('loading-overlay').style.display = 'none';
                        }
                    }
                } else {
                    await guiXuAlert("没有可清除的存档数据。");
                }
            } catch (e) {
                console.error("检测世界书激活条目失败:", e);
                await guiXuAlert("没有可清除的存档数据。");
            }
            return;
        }

        const confirmMsg = `你确定要清除所有 ${saveKeys.length} 个存档吗？\n此操作将删除所有存档、关联的世界书快照以及所有激活的“本世历程/往世涟漪”条目，且不可恢复。`;
        if (!(await guiXuConfirm(confirmMsg, "高危操作确认"))) return;

        document.getElementById('loading-overlay').style.display = 'flex';
        try {
            const entryNamesToDelete = new Set();
            const indicesToDelete = new Set();

            saveKeys.forEach(slotId => {
                entryNamesToDelete.add(`存档:${slotId}`);
                const saveData = allSaves[slotId];
                if (saveData) {
                    indicesToDelete.add(saveData.unified_index || 1);
                    if (saveData.lorebook_entries) {
                        Object.values(saveData.lorebook_entries).forEach(name => {
                            if (name) entryNamesToDelete.add(name);
                        });
                    }
                }
            });

            // Delete all save entries and their backups
            if (entryNamesToDelete.size > 0) {
                await TavernHelper.updateWorldbookWith(bookName, (worldbook) => {
                    return worldbook.filter(entry => !entryNamesToDelete.has(entry.name));
                });
            }

            // Delete all active lore entries associated with the deleted saves
            for (const idx of indicesToDelete) {
                await deleteWorldLoreForIndex(idx);
            }

            await guiXuAlert(`所有存档及关联的世界书条目已清除。`);
            showSaveLoadManager();

        } catch (error) {
            console.error('清除所有存档时出错:', error);
            await guiXuAlert(`清除存档失败: ${error.message}`, '错误');
        } finally {
            document.getElementById('loading-overlay').style.display = 'none';
        }
    }

    async function exportSave(slotId) {
        const allSaves = await getSavesFromStorage();
        const saveData = allSaves[slotId];
        if (!saveData) return;

        try {
            const dataToExport = {
                exportVersion: '1.0',
                exportedAt: new Date().toISOString(),
                saveData: saveData,
                lorebookData: []
            };

            if (saveData.lorebook_entries) {
                const bookName = WorldBookManager.LOREBOOK_NAME;
                const entryNames = Object.values(saveData.lorebook_entries);
                const allEntries = await TavernHelper.getWorldbook(bookName);
                dataToExport.lorebookData = allEntries.filter(e => entryNames.includes(e.name));
            }

            const fileName = `${(saveData.save_name || `guixu_save_${slotId}`).replace(/[^a-z0-9]/gi, '_')}.json`;
            exportData(JSON.stringify(dataToExport, null, 2), fileName);
            await guiXuAlert('存档已成功导出！');
        } catch (error) {
            console.error('导出存档失败:', error);
            await guiXuAlert(`导出失败: ${error.message}`, '错误');
        }
    }

    async function _upsertSaveEntry(slotId, saveData) {
        const bookName = WorldBookManager.LOREBOOK_NAME;
        const entryName = `存档:${slotId}`;
        const content = JSON.stringify(saveData || {}, null, 0);

        await TavernHelper.updateWorldbookWith(bookName, (worldbook) => {
            const existingIndex = worldbook.findIndex(e => e.name === entryName);
            if (existingIndex > -1) {
                worldbook[existingIndex].content = content;
            } else {
                worldbook.push({
                    name: entryName,
                    content: content,
                    keys: [entryName],
                    enabled: false,
                    position: { type: 'before_character_definition', order: 10 },
                    strategy: { type: 'constant' }
                });
            }
            return worldbook;
        });
    }

    async function handleFileImport(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = async (e) => {
            try {
                const importedData = JSON.parse(e.target.result);
                let saveDataToImport;
                let lorebookDataToImport = [];

                if (importedData.exportVersion === '1.0') { // New format
                    saveDataToImport = importedData.saveData;
                    lorebookDataToImport = importedData.lorebookData || [];
                } else { // Old format
                    saveDataToImport = importedData;
                }

                if (!saveDataToImport || !saveDataToImport.timestamp || !saveDataToImport.mvu_data) {
                    throw new Error('存档文件格式无效。');
                }

                const slotId = await promptForSlotSelection(saveDataToImport.save_name || '导入的存档');
                if (!slotId) return;
                
                const bookName = WorldBookManager.LOREBOOK_NAME;
                
                // Handle lorebook entries
                if (lorebookDataToImport.length > 0) {
                    await TavernHelper.updateWorldbookWith(bookName, (worldbook) => {
                        const existingNames = new Set(worldbook.map(e => e.name));
                        lorebookDataToImport.forEach(entry => {
                            if (!existingNames.has(entry.name)) {
                                const { uid, ...newEntry } = entry;
                                worldbook.push(newEntry);
                            }
                        });
                        return worldbook;
                    });
                }
                
                await _upsertSaveEntry(slotId, saveDataToImport);
                await guiXuAlert(`存档已成功导入到 ${slotId.replace('slot_', '存档位 ')}。`);
                showSaveLoadManager();

            } catch (error) {
                await guiXuAlert(`导入失败: ${error.message}`, '错误');
            }
        };
        reader.readAsText(file);
        event.target.value = '';
    }

    function promptForSlotSelection(importName) {
        return new Promise(resolve => {
            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.style.cssText = 'display: flex; z-index: 2001;';
            let slotsHtml = '';
            for (let i = 1; i <= 5; i++) slotsHtml += `<button class="theme-btn theme-btn-gold" data-slot-id="slot_${i}">存档位 ${i}</button>`;
            modal.innerHTML = `
              <div class="modal-content" style="width: 450px; height: auto;">
                <h2 class="modal-title">选择导入位置</h2>
                <div class="modal-body" style="padding: 20px;">
                  <p>请选择一个存档位以导入 "${importName}":</p>
                  <div style="display: flex; justify-content: center; gap: 10px; flex-wrap: wrap; margin-top:20px;">${slotsHtml}</div>
                  <div class="modal-actions"><button class="theme-btn theme-btn-red" id="import-cancel-btn">取消</button></div>
                </div>
              </div>`;
            document.body.appendChild(modal);
            modal.addEventListener('click', (e) => {
                const target = e.target;
                if (target.dataset.slotId) {
                    resolve(target.dataset.slotId);
                    modal.remove();
                } else if (target.id === 'import-cancel-btn' || target === modal) {
                    resolve(null);
                    modal.remove();
                }
            });
        });
    }
    
    function setupSaveManagerEventListeners() {
        document.getElementById('show-save-manager-btn').addEventListener('click', () => showSaveLoadManager());
        const modal = document.getElementById('save-load-modal');
        if (!modal) return;
        modal.addEventListener('click', (e) => {
            const button = e.target.closest('[data-action]');
            if (e.target.matches('.modal-overlay')) modal.style.display = 'none';
            if (!button) return;
            const action = button.dataset.action;
            const slotId = button.closest('.save-slot')?.dataset.slotId;
            switch (action) {
                case 'close-modal': modal.style.display = 'none'; break;
                case 'load-slot': if (slotId) loadGame(slotId); break;
                case 'export-slot': if (slotId) exportSave(slotId); break;
                case 'delete-slot': if (slotId) deleteSave(slotId); break;
                case 'import-save': document.getElementById('import-save-file-input').click(); break;
                case 'clear-all-saves': clearAllSaves(); break;
            }
        });
        document.getElementById('import-save-file-input').addEventListener('change', handleFileImport);
    }
    // --- END OF SAVE/LOAD MANAGER LOGIC ---
    
    // === [PORTED] Background Settings Logic ===
    const BG_SETTINGS_KEY = 'guixu_background_settings_v2';
    const defaultBgSettings = { network: true, opacity: 0.5, blur: 0, local: false, localImage: null };
    let backgroundSettings = {};
    let bgInterval;

    function loadBackgroundSettings() {
        try {
            const saved = localStorage.getItem(BG_SETTINGS_KEY);
            backgroundSettings = saved ? { ...defaultBgSettings, ...JSON.parse(saved) } : { ...defaultBgSettings };
        } catch (e) {
            backgroundSettings = { ...defaultBgSettings };
        }
    }
    function saveBackgroundSettings() { localStorage.setItem(BG_SETTINGS_KEY, JSON.stringify(backgroundSettings)); }
    
    function applyBackgroundSettings() {
        const startupPage = document.getElementById('startup-page');
        clearInterval(bgInterval);
        if (backgroundSettings.local && backgroundSettings.localImage) {
            startupPage.style.backgroundImage = `url(${backgroundSettings.localImage})`;
        } else if (backgroundSettings.network) {
            startBgChanger();
        } else {
            startupPage.style.backgroundImage = 'none';
        }
        startupPage.style.setProperty('--bg-overlay-color', `rgba(0, 0, 0, ${backgroundSettings.opacity})`);
        startupPage.style.setProperty('--bg-backdrop-filter', `blur(${backgroundSettings.blur}px)`);
        startupPage.style.backgroundColor = (!backgroundSettings.local && !backgroundSettings.network) ? '#0a0a14' : 'transparent';
    }
    
    function startBgChanger() {
        const networkBackgrounds = [
          'https://i.postimg.cc/GhbMWb4H/rgthree-compare-temp-bjhol-00011.png',
          'https://i.postimg.cc/qMQm0WKQ/rgthree-compare-temp-bjhol-00008.png',
          'https://i.postimg.cc/pVfGcmXw/rgthree-compare-temp-bjhol-00006.png',
          'https://i.postimg.cc/XY40DMb8/rgthree-compare-temp-bjhol-00003.png',
        ];
        clearInterval(bgInterval);
        const setRandomBg = () => {
          document.getElementById('startup-page').style.backgroundImage = `url('${networkBackgrounds[Math.floor(Math.random() * networkBackgrounds.length)]}')`;
        };
        setRandomBg();
        bgInterval = setInterval(setRandomBg, 15000);
    }
    
    function renderSettingsModal() {
      document.getElementById('settings-modal-body').innerHTML = `
          <div class="settings-group">
              <span class="settings-label">网络背景</span>
              <div class="settings-controls"><label class="toggle-switch"><input type="checkbox" id="network-bg-toggle"><span class="slider"></span></label></div>
          </div>
          <div class="settings-group">
              <span class="settings-label">本地壁纸</span>
              <div class="settings-controls">
                  <button id="upload-local-bg-btn" class="theme-btn theme-btn-gold btn-small">选择文件</button>
                  <label class="toggle-switch"><input type="checkbox" id="local-bg-toggle"><span class="slider"></span></label>
              </div>
          </div>
          <div>
              <div class="section-title" style="font-size: 1.1rem; text-align:left; border:none; padding-bottom: 10px;">背景效果</div>
              <div class="settings-slider-group">
                  <div class="slider-container">
                      <label for="opacity-slider">遮罩不透明度</label>
                      <input type="range" id="opacity-slider" min="0" max="1" step="0.05">
                      <span id="opacity-value" class="slider-value"></span>
                  </div>
                  <div class="slider-container">
                      <label for="blur-slider">背景模糊</label>
                      <input type="range" id="blur-slider" min="0" max="10" step="0.1">
                      <span id="blur-value" class="slider-value"></span>
                  </div>
              </div>
          </div>`;
      document.getElementById('network-bg-toggle').addEventListener('change', e => { backgroundSettings.network = e.target.checked; if(e.target.checked) backgroundSettings.local = false; saveAndApplyBg(); });
      document.getElementById('local-bg-toggle').addEventListener('change', e => { backgroundSettings.local = e.target.checked; if(e.target.checked) { if(!backgroundSettings.localImage) { alert("请先选择本地壁纸。"); backgroundSettings.local = false; } else { backgroundSettings.network = false; } } saveAndApplyBg(); });
      document.getElementById('opacity-slider').addEventListener('input', e => { backgroundSettings.opacity = parseFloat(e.target.value); saveAndApplyBg(); });
      document.getElementById('blur-slider').addEventListener('input', e => { backgroundSettings.blur = parseFloat(e.target.value); saveAndApplyBg(); });
      document.getElementById('upload-local-bg-btn').addEventListener('click', () => document.getElementById('local-bg-input').click());
      document.getElementById('local-bg-input').addEventListener('change', handleLocalBgUpload);
    }
    
    function updateSettingsUI() {
      document.getElementById('network-bg-toggle').checked = backgroundSettings.network;
      document.getElementById('local-bg-toggle').checked = backgroundSettings.local;
      document.getElementById('opacity-slider').value = backgroundSettings.opacity;
      document.getElementById('opacity-value').textContent = backgroundSettings.opacity.toFixed(2);
      document.getElementById('blur-slider').value = backgroundSettings.blur;
      document.getElementById('blur-value').textContent = `${backgroundSettings.blur.toFixed(1)}px`;
    }
    
    function saveAndApplyBg() { saveBackgroundSettings(); applyBackgroundSettings(); updateSettingsUI(); }
    
    function handleLocalBgUpload(e) {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
            backgroundSettings.localImage = event.target.result;
            backgroundSettings.local = true;
            backgroundSettings.network = false;
            saveAndApplyBg();
        };
        reader.readAsDataURL(file);
    }

    document.addEventListener('DOMContentLoaded', () => {
      // Main UI Listeners
      document.getElementById('show-editor-btn').addEventListener('click', async () => {
          currentEditingPreset = null;
          await showView('editor-container');
      });
      document.getElementById('back-to-main-btn').addEventListener('click', () => showView('main-page-content'));
      document.getElementById('modal-save-btn').addEventListener('click', saveModalData);
      document.getElementById('modal-cancel-btn').addEventListener('click', hideModal);
      
      // Setup modules
      setupEditorEventListeners();
      setupGlobalControls();
      bindGameFlowEvents();
      setupSaveManagerEventListeners();
      
      // === [PORTED] Settings Modal Listeners ===
      const settingsModal = document.getElementById('settings-modal');
      const floatingSettingsBtn = document.getElementById('floating-settings-btn');
      const closeModalSettingsBtn = document.getElementById('modal-close-settings-btn');
      if (floatingSettingsBtn) floatingSettingsBtn.addEventListener('click', () => {
          updateSettingsUI();
          settingsModal.style.display = 'flex';
      });
      if (closeModalSettingsBtn) closeModalSettingsBtn.addEventListener('click', () => settingsModal.style.display = 'none');
      if (settingsModal) settingsModal.addEventListener('click', (e) => {
          if (e.target === settingsModal) settingsModal.style.display = 'none';
      });
      
      // Initialize Background
      loadBackgroundSettings();
      applyBackgroundSettings();
      renderSettingsModal();
      window.ensureBackgroundImage = applyBackgroundSettings;
      window.addEventListener('focus', applyBackgroundSettings);


      document.getElementById('clear-cache-btn').addEventListener('click', refreshLocalStorage);
      document.getElementById('start-game-btn').addEventListener('click', async () => {
        await refreshLocalStorage();
        await loadEditorData();
        renderStartupChoice();
        await showView('startup-choice-container');
      });

      function renderUI() {
        const setupForm = document.getElementById('setup-form');
        if (!setupForm) return;
        let html = '';
        switch (gameState.currentStep) {
          case 'difficulty': html = renderDifficultySelection(); break;
          case 'attributes': html = renderAttributeAllocation(); break;
          case 'talents': html = renderTalentSelection(); break;
          case 'background': html = renderBackgroundSelection(); break;
          case 'gender': html = renderGenderSelection(); break;
        }
        setupForm.innerHTML = html;
      }

      function renderDifficultySelection() {
        return `<div class="form-section"><label>第一步：选择难度</label><div class="difficulty-selection">${Object.entries(GAME_DATA.difficulties).map(([id, diff]) => `<div class="difficulty-card ${gameState.selectedDifficulty === id ? 'selected' : ''}" data-difficulty-id="${id}"><div class="difficulty-header"><span class="difficulty-name">${diff.name}</span><span class="points-value">${diff.points}点</span></div></div>`).join('')}</div></div>`;
      }

      function renderAttributeAllocation() {
        return `<div id="points-tracker">剩余点数: ${gameState.remainingPoints}</div><div class="form-section"><label>第二步：分配属性</label><div class="attributes-grid">${Object.entries(GAME_DATA.attributes).map(([id, attr]) => { const finalValue = gameState.finalAttributes[id]; const spentValue = gameState.spentAttributePoints[id]; return `<div class="attribute-card"><div class="attribute-tooltip">${attr.description}</div><div class="attribute-header"><span class="attribute-name">${attr.name}</span><div class="attribute-value"><button type="button" class="value-btn decrease-btn" data-attribute="${id}" ${spentValue <= 0 ? 'disabled' : ''}>-</button><input type="number" class="value-input" value="${finalValue}" data-attribute-id="${id}"><button type="button" class="value-btn increase-btn" data-attribute="${id}" ${(id === 'qi_yun' ? gameState.remainingPoints < 10 : gameState.remainingPoints <= 0) ? 'disabled' : ''}>+</button></div></div></div>`; }).join('')}</div></div><button type="button" id="prev-step-btn" class="generate-btn">返回</button><button type="button" id="next-step-btn" class="generate-btn">下一步：选择天赋</button>`;
      }

    function renderTalentSelection() {
        let availableTalents;
        if (gameState.startingPresetName) {
            const preset = editorData.presets.find(p => p.name === gameState.startingPresetName);
            const presetSeries = preset ? (preset.series || '').trim() : '';
            availableTalents = editorData.talents.filter(talent => {
                const talentSeries = (talent.series || '').trim();
                return talentSeries === '' || talentSeries === presetSeries;
            });
        } else {
            availableTalents = editorData.talents.filter(talent => (talent.series || '').trim() === '');
        }

        availableTalents.sort((a, b) => {
            const isRequiredA = gameState.requiredTalents.includes(a.id);
            const isSelectedA = gameState.selectedTalents.includes(a.id);
            const statusPriorityA = isRequiredA ? 0 : (isSelectedA ? 1 : 2);

            const isRequiredB = gameState.requiredTalents.includes(b.id);
            const isSelectedB = gameState.selectedTalents.includes(b.id);
            const statusPriorityB = isRequiredB ? 0 : (isSelectedB ? 1 : 2);

            if (statusPriorityA !== statusPriorityB) {
                return statusPriorityA - statusPriorityB;
            }

            const isSeriesA = (a.series || '').trim() !== '';
            const isSeriesB = (b.series || '').trim() !== '';
            const typePriorityA = isSeriesA ? 0 : 1;
            const typePriorityB = isSeriesB ? 0 : 1;

            if (typePriorityA !== typePriorityB) {
                return typePriorityA - typePriorityB;
            }

            return (b.cost || 0) - (a.cost || 0);
        });

        return `<div id="points-tracker">剩余点数: ${gameState.remainingPoints}</div><div class="form-section"><label>第三步：选择天赋</label><div class="talent-selection">${availableTalents.map(talent => { const isSelected = gameState.selectedTalents.includes(talent.id); const isRequired = gameState.requiredTalents.includes(talent.id); const cost = talent.cost || 0; const canAfford = gameState.remainingPoints >= cost || isSelected; const seriesString = String(talent.series || '').trim(); const seriesInfo = seriesString ? `[${seriesString}] ` : ''; let cardClass = 'talent-card'; if (isSelected) cardClass += ' selected'; if (isRequired) cardClass += ' required'; else if (!canAfford) cardClass += ' disabled'; return `<div class="${cardClass}" data-talent-id="${talent.id}"><div class="talent-header"><span class="talent-name">${seriesInfo}${talent.name} (${talent.author})</span><span class="points-value">${cost}点</span></div><p class="talent-description" style="white-space: pre-wrap;">${talent.description}</p></div>`; }).join('')}</div></div><div class="form-section"><label for="custom-talent">自定义天赋 (不消耗点数)</label><textarea id="custom-talent" class="custom-talent-input" rows="2" placeholder="输入你的自定义天赋...">${gameState.customTalent}</textarea></div><button type="button" id="prev-step-btn" class="generate-btn">返回</button><button type="button" id="next-step-btn" class="generate-btn">下一步：选择背景</button>`;
    }

      function renderBackgroundSelection() {
        let availableBackgrounds;
        if (gameState.startingPresetName) {
            const preset = editorData.presets.find(p => p.name === gameState.startingPresetName);
            const presetSeries = preset ? (preset.series || '').trim() : '';
            availableBackgrounds = editorData.backgrounds.filter(bg => {
                const bgSeries = (bg.series || '').trim();
                return bgSeries === '' || bgSeries === presetSeries;
            });
        } else {
            availableBackgrounds = editorData.backgrounds.filter(bg => (bg.series || '').trim() === '');
        }
        return `<div id="points-tracker">剩余点数: ${gameState.remainingPoints}</div><div class="form-section"><label>第四步：选择出生背景</label><div class="background-selection">${availableBackgrounds.map(bg => { const isSelected = gameState.selectedBackground === bg.id; const seriesString = String(bg.series || '').trim(); const seriesInfo = seriesString ? `[${seriesString}] ` : ''; return `<div class="background-card ${isSelected ? 'selected' : ''}" data-background-id="${bg.id}"><div class="talent-header"><span class="talent-name">${seriesInfo}${bg.name} (${bg.author})</span></div><p class="talent-description" style="white-space: pre-wrap;">${bg.description}</p></div>`; }).join('')}</div></div><div class="form-section"><label for="custom-background">自定义背景 (不消耗点数)</label><textarea id="custom-background" class="custom-talent-input" rows="2" placeholder="输入你的自定义背景...">${gameState.customBackground}</textarea></div><button type="button" id="prev-step-btn" class="generate-btn">返回</button><button type="button" id="next-step-btn" class="generate-btn">下一步：选择性别</button>`;
      }

      function renderGenderSelection() {
        return `<div class="form-section"><label>第五步：选择性别</label><div class="difficulty-selection">${Object.entries(GAME_DATA.genders).map(([id, gender]) => `<div class="gender-card ${gameState.selectedGender === id ? 'selected' : ''}" data-gender-id="${id}"><div class="talent-header"><span class="talent-name">${gender.name}</span></div></div>`).join('')}</div></div><button type="button" id="prev-step-btn" class="generate-btn">返回</button><button type="button" id="generate-startup-btn" class="generate-btn">生成开局</button>`;
      }

      function bindGameFlowEvents() {
        const setupForm = document.getElementById('setup-form');
        if (!setupForm) return;
        setupForm.addEventListener('click', e => {
          const target = e.target;
          const diffCard = target.closest('.difficulty-card');
          if (diffCard) {
            const id = diffCard.dataset.difficultyId;
            gameState.selectedDifficulty = id;
            gameState.totalPoints = GAME_DATA.difficulties[id].points;
            gameState.currentStep = 'attributes';
            renderUI();
            return;
          }
          const valueBtn = target.closest('.value-btn');
          if (valueBtn && !valueBtn.disabled) {
            const attrId = valueBtn.dataset.attribute;
            const cost = attrId === 'qi_yun' ? 10 : 1;
            if (valueBtn.classList.contains('increase-btn') && gameState.remainingPoints >= cost) {
              gameState.spentAttributePoints[attrId]++;
            } else if (valueBtn.classList.contains('decrease-btn') && gameState.spentAttributePoints[attrId] > 0) {
              gameState.spentAttributePoints[attrId]--;
            }
            renderUI();
            return;
          }
          const talentCard = target.closest('.talent-card[data-talent-id]');
          if (talentCard && !talentCard.classList.contains('disabled')) {
            if (talentCard.classList.contains('required')) return;
            const id = talentCard.dataset.talentId;
            const index = gameState.selectedTalents.indexOf(id);
            if (index > -1) gameState.selectedTalents.splice(index, 1);
            else gameState.selectedTalents.push(id);
            renderUI();
            return;
          }
          const bgCard = target.closest('.background-card');
          if (bgCard) {
            const id = bgCard.dataset.backgroundId;
            gameState.selectedBackground = gameState.selectedBackground === id ? null : id;
            renderUI();
            return;
          }
          const genderCard = target.closest('.gender-card[data-gender-id]');
          if (genderCard) {
            const id = genderCard.dataset.genderId;
            gameState.selectedGender = gameState.selectedGender === id ? null : id;
            renderUI();
            return;
          }
          if (target.id === 'next-step-btn') {
            if (gameState.currentStep === 'attributes') gameState.currentStep = 'talents';
            else if (gameState.currentStep === 'talents') gameState.currentStep = 'background';
            else if (gameState.currentStep === 'background') gameState.currentStep = 'gender';
            renderUI();
            return;
          }
          if (target.id === 'prev-step-btn') {
            if (gameState.currentStep === 'attributes') {
              gameState = getNewGameState();
              showView('startup-choice-container');
              renderStartupChoice();
            } else if (gameState.currentStep === 'talents') gameState.currentStep = 'attributes';
            else if (gameState.currentStep === 'background') gameState.currentStep = 'talents';
            else if (gameState.currentStep === 'gender') gameState.currentStep = 'background';
            renderUI();
            return;
          }
          if (target.id === 'generate-startup-btn') {
            generateStartup();
            return;
          }
        });
        setupForm.addEventListener('input', e => {
          if (e.target.id === 'custom-talent') gameState.customTalent = e.target.value;
          else if (e.target.id === 'custom-background') gameState.customBackground = e.target.value;
        });
        setupForm.addEventListener('blur', e => {
            if (e.target.classList.contains('value-input')) {
              const attrId = e.target.dataset.attributeId;
              const baseValue = baseAttributes[attrId];
              let newValue = parseInt(e.target.value, 10);
              if (isNaN(newValue) || newValue < baseValue) {
                renderUI(); return;
              }
              const oldSpent = { ...gameState.spentAttributePoints };
              gameState.spentAttributePoints[attrId] = newValue - baseValue;
              if (gameState.spentPoints > gameState.totalPoints) {
                gameState.spentAttributePoints = oldSpent;
              }
              renderUI();
            }
          }, true);
        setupForm.addEventListener('keypress', e => {
                    if (e.target.classList.contains('value-input') && e.key === 'Enter') e.target.blur();
        });
      }

      async function generateStartup() {
        if (!gameState.selectedGender) return await guiXuAlert('请选择性别');
        document.getElementById('loading-overlay').style.display = 'flex';
        try {
          const talentsText = gameState.selectedTalents.map(id => {
              const talent = editorData.talents.find(t => t.id === id);
              return talent ? `              - ${talent.name}: ${talent.description}` : '';
          }).filter(Boolean).join('\n');
          const customTalentText = gameState.customTalent ? `              - 自定义: ${gameState.customTalent}` : '';
          const backgroundText = (() => {
            if (gameState.customBackground) return `              - 自定义: ${gameState.customBackground}`;
            const bgInfo = editorData.backgrounds.find(bg => bg.id === gameState.selectedBackground);
            return bgInfo ? `              - ${bgInfo.name}: ${bgInfo.description}` : '';
          })();
          const genderText = `              - ${GAME_DATA.genders[gameState.selectedGender].name}`;
          const playerInput = `
- **最终属性**:
${Object.entries(gameState.finalAttributes).map(([id, value]) => `              - ${GAME_DATA.attributes[id].name}: ${value}`).join('\n')}
- **天赋**:
${talentsText}
${customTalentText}
- **出生背景**:
${backgroundText}
- **性别**:
${genderText}`.trim();

          const prompt = `<开局设定>
# 这是角色<user>的开局设定
1.请根据以下设定，进行开局的生成以及变量的初始化
2.请忽略所有<status_current_variables>中关于<user>的变量内容，而是根据以下“开局设定”进行全部初始化设定
3.对于开局的故事描写，应该使用沉浸感式进行描述，避免出现天赋名称、点数、背景等字样，这样会大幅度破坏开局的代入感
4.对于所有需要数值的变量，比如功法、武器、灵根、天赋等，必须按照<数值参考>中的数值体系，设定合理的数值，但避免留空，都需要填写数值
## 开局设定
${playerInput}
1.对于开局点数，这只是<user>开局设定的基础值，你必须要参考<境界数值参考>然后根据<user>的对应开局背景境界来计算符合要求的基础数值，而不是单纯只看开局给的基础值
2.对于天赋，需要根据天赋的描述，参考<品阶参考>、<数值参考>，设定合理的数值和品阶。但注意避免全神品、全仙品，高等级天赋极其稀有，请根据天赋的描述酌情设定品阶
3.对于灵根，应该依据背景，参考<品阶参考>、<数值参考>，设置一个灵根，同时也需要酌情处理品阶问题
4.对于背景，需要合理的引入剧情，如果是穿越者，需要描述清楚详情，如果是原主，则不应该突兀引入天赋等介绍，这应该是与之俱来的，而非突然觉醒
</开局设定>`;

          const generateConfig = {
            injects: [{
                role: 'user',
                content: prompt,
                position: 'before_prompt',
                depth: 0,
                should_scan: true,
            }],
            should_stream: false,
          };
          const mvuScript = await TavernHelper.generate(generateConfig);
          if (!mvuScript) throw new Error('AI未能生成开局脚本。');

          const messages = await getChatMessages(0);
          if (!messages || messages.length === 0) throw new Error('无法获取到第0层消息，无法写入开局设定。');

          const messageZero = messages[0];
          messageZero.message = mvuScript;
          messageZero.data = {};
          await TavernHelper.setChatMessages([messageZero], { refresh: 'all' });
        } catch (error) {
          console.error('生成开局时出错:', error);
          await guiXuAlert(`生成开局失败: ${error.message}\n详情请查看控制台。`, '错误');
        } finally {
          document.getElementById('loading-overlay').style.display = 'none';
        }
      }

      function renderStartupChoice() {
        const container = document.getElementById('startup-choice-container');
        if (!container) return;
        const presetsHtml = editorData.presets.length > 0 ? editorData.presets.map(p => `<div class="choice-item" data-preset-name="${p.name}"><div class="choice-item-title">${p.name}</div><div class="choice-item-desc">作者: ${p.author || '未知'} | 点数: ${p.points || 40}</div></div>`).join('') : '<p style="color: #ccc; text-align: center;">没有可用的预设。</p>';
        const difficultiesHtml = Object.entries(GAME_DATA.difficulties).map(([id, diff]) => `<div class="choice-item" data-difficulty-id="${id}"><div class="choice-item-title">${diff.name}</div><div class="choice-item-desc">初始点数: ${diff.points}</div></div>`).join('');
        container.innerHTML = `<h1 class="title" style="margin-bottom: 30px;">选择你的开局方式</h1><div class="startup-choice-layout"><div class="choice-column"><h2>选择预设</h2><div class="choice-list">${presetsHtml}</div></div><div class="choice-column"><h2>标准开局</h2><div class="choice-list">${difficultiesHtml}</div></div></div><button type="button" id="back-to-main-from-choice-btn" class="generate-btn" style="margin-top: 30px;">返回主页</button>`;
      }

      document.getElementById('startup-choice-container').addEventListener('click', e => {
        const choiceItem = e.target.closest('.choice-item');
        if (choiceItem) {
          if (choiceItem.dataset.presetName) startWithPreset(choiceItem.dataset.presetName);
          else if (choiceItem.dataset.difficultyId) startWithDifficulty(choiceItem.dataset.difficultyId);
        } else if (e.target.id === 'back-to-main-from-choice-btn') {
          showView('main-page-content');
        }
      });

      async function togglePresetWorldbooks(preset) {
          const series = (preset.series || '').trim();
          const author = (preset.author || '').trim();
          if (!series || !author) {
              console.log(`预设 "${preset.name}" 未设置系列或作者，跳过世界书自动切换。`);
              return;
          }

          const targetPrefix = `【世界书】【${series}】【${author}】`;
          console.log(`正在为预设 "${preset.name}" 切换世界书，目标前缀: ${targetPrefix}`);

          try {
              let changed = false;
              await WorldBookManager._saveOrUpdateWith(worldbook => {
                  worldbook.forEach(entry => {
                      if (entry.name.startsWith('【世界书】【') && entry.name.includes('】【')) {
                          if (entry.name.startsWith(targetPrefix)) {
                              if (!entry.enabled) {
                                  entry.enabled = true;
                                  changed = true;
                              }
                          } else {
                              if (entry.enabled) {
                                  entry.enabled = false;
                                  changed = true;
                              }
                          }
                      }
                  });
                  return worldbook;
              });
              if (changed) {
                  console.log("世界书状态已根据预设自动更新。");
                  await loadEditorData(); // Refresh data silently
              }
          } catch (error) {
              console.error('自动切换世界书状态时出错:', error);
              await guiXuAlert('自动切换世界书状态失败，详情请查看控制台。', '错误');
          }
      }


      function startWithDifficulty(difficultyId) {
        const difficulty = GAME_DATA.difficulties[difficultyId];
        if (!difficulty) return;
        gameState = getNewGameState();
        gameState.selectedDifficulty = difficultyId;
        gameState.totalPoints = difficulty.points;
        gameState.currentStep = 'attributes';
        showView('setup-form');
        renderUI();
      }

      async function startWithPreset(presetName) {
        const preset = editorData.presets.find(p => p.name === presetName);
        if (!preset) return;
        if (!(await guiXuConfirm(`确定要加载预设 "${presetName}" 吗？\n这将自动启用其关联的系列世界书。`))) return;
        
        await togglePresetWorldbooks(preset);

        gameState = getNewGameState();
        gameState.totalPoints = preset.points || 40;
        
        if (preset.attributes) {
          gameState.spentAttributePoints = { ...gameState.spentAttributePoints, ...preset.attributes };
        }
        
        gameState.requiredTalents = [...(preset.requiredTalents || [])];
        gameState.selectedTalents = [...(preset.requiredTalents || []), ...(preset.optionalTalents || [])];
        gameState.startingPresetName = preset.name;
        gameState.currentStep = 'attributes';
        showView('setup-form');
        renderUI();
      }
   });
  })();
</script>
<script>
  // 类脑/旅程梦星作品，禁止二传，禁止商业化，均无偿免费开源分享
  // --- 归墟Plus 读写序号控制 ---
  (function () {
    'use strict';
    document.addEventListener('DOMContentLoaded', () => {
      const unifiedIndexInput = document.getElementById('unified-index-input');
      const autoToggleCheckbox = document.getElementById('auto-toggle-lorebook-checkbox');
      // === [PORTED] Get stepper buttons ===
      const incrementBtn = document.getElementById('index-increment-btn');
      const decrementBtn = document.getElementById('index-decrement-btn');

      if (!unifiedIndexInput || !autoToggleCheckbox || !incrementBtn || !decrementBtn) return;

      const state = { unifiedIndex: 1, isAutoToggleEnabled: false };

      // === [PORTED] Function to update button state ===
      function updateStepperButtons() {
          const currentValue = parseInt(unifiedIndexInput.value, 10);
          decrementBtn.disabled = (currentValue <= 1);
      }

      async function updateAutoToggledEntries(andDisableAll = false) {
        if (typeof TavernHelper === 'undefined' || typeof TavernHelper.updateWorldbookWith === 'undefined') return;
        const bookName = '归墟（拼好卡）';
        const index = state.unifiedIndex;
        const journeyKey = index > 1 ? `本世历程(${index})` : '本世历程';
        const pastLivesKey = index > 1 ? `往世涟漪(${index})` : '往世涟漪';

        try {
            await TavernHelper.updateWorldbookWith(bookName, (allEntries) => {
                const entriesToCreate = [];
                if (!allEntries.find(e => e.name === journeyKey)) {
                    const base = allEntries.find(e => e.name === '本世历程');
                    if (base) entriesToCreate.push({ ...base, uid: undefined, name: journeyKey, content: '', strategy: { ...base.strategy, keys: [...(base.strategy?.keys || []), journeyKey] }, enabled: true });
                }
                if (!allEntries.find(e => e.name === pastLivesKey)) {
                    const base = allEntries.find(e => e.name === '往世涟漪');
                    if (base) entriesToCreate.push({ ...base, uid: undefined, name: pastLivesKey, content: '', strategy: { ...base.strategy, keys: [...(base.strategy?.keys || []), pastLivesKey] }, enabled: true });
                }
                allEntries.push(...entriesToCreate);

                for (const entry of allEntries) {
                    const isJourney = entry.name.startsWith('本世历程');
                    const isPast = entry.name.startsWith('往世涟漪');
                    if (!isJourney && !isPast) continue;
                    const isTarget = entry.name === journeyKey || entry.name === pastLivesKey;
                    const shouldBeEnabled = isTarget && !andDisableAll && state.isAutoToggleEnabled;
                    if (entry.enabled !== shouldBeEnabled) {
                        entry.enabled = shouldBeEnabled;
                    }
                }
                return allEntries;
            });
        } catch (error) {
          console.error('[归墟] 更新世界书条目状态时出错:', error);
        }
      }

      function saveState() {
        try {
          localStorage.setItem('guixu_unified_index', state.unifiedIndex);
          localStorage.setItem('guixu_auto_toggle_enabled', state.isAutoToggleEnabled);
        } catch (e) {
          console.error('保存状态失败:', e);
        }
      }

      function loadState() {
        try {
          state.unifiedIndex = parseInt(localStorage.getItem('guixu_unified_index'), 10) || 1;
          unifiedIndexInput.value = state.unifiedIndex;
          state.isAutoToggleEnabled = localStorage.getItem('guixu_auto_toggle_enabled') === 'true';
          autoToggleCheckbox.checked = state.isAutoToggleEnabled;
          // === [PORTED] Update button state on load ===
          updateStepperButtons();
        } catch (e) {
          console.error('加载状态失败:', e);
        }
      }

      loadState();
      unifiedIndexInput.addEventListener('change', e => {
        const newIndex = parseInt(e.target.value, 10);
        if (!isNaN(newIndex) && newIndex > 0) {
          state.unifiedIndex = newIndex;
          saveState();
          if (state.isAutoToggleEnabled) updateAutoToggledEntries();
        } else {
          e.target.value = state.unifiedIndex;
        }
        // === [PORTED] Update button state on change ===
        updateStepperButtons();
      });
      autoToggleCheckbox.addEventListener('change', e => {
        state.isAutoToggleEnabled = e.target.checked;
        saveState();
        updateAutoToggledEntries(!state.isAutoToggleEnabled);
      });
      
      // === [PORTED] Event listeners for stepper buttons ===
      incrementBtn.addEventListener('click', () => {
          let currentValue = parseInt(unifiedIndexInput.value, 10);
          unifiedIndexInput.value = isNaN(currentValue) ? 1 : currentValue + 1;
          unifiedIndexInput.dispatchEvent(new Event('change'));
      });

      decrementBtn.addEventListener('click', () => {
          let currentValue = parseInt(unifiedIndexInput.value, 10);
          if (!isNaN(currentValue) && currentValue > 1) {
              unifiedIndexInput.value = currentValue - 1;
              unifiedIndexInput.dispatchEvent(new Event('change'));
          }
      });
    });
  })();
</script>
<script>
  // --- "关于归墟" 模态窗口逻辑 (No Encryption) ---
  (function() {
    'use strict';

    const contentCredits = `

**【大家好，这里是梦星，这是我的第15张卡，也是我目前花费精力最大的一张卡】**
**【感谢您的游玩，希望能多些反馈或者游玩截图，您的点赞和评论是我创造的最大动力】**

**【归墟应该就是我的封笔作了，所以精益求精，打磨了很久，非常抱歉，但还是希望给大家留下一个好印象，或者说，一个很棒的梦星大人 】**
**【祝大家玩的开心！】**


**【必备前置：酒馆助手 】**
**【遇到问题怎么办？帖子标注——kk的游玩攻略及其问题排查 ——排查不行——看标注，查找相同问题/搜索关键词——还不行，带上详细截图（完整的正文和最后的变量更新，api端口，酒馆助手，正则列表截图）提问】**

 **【1.禁止二传，允许二创】**
**【2.禁止一切商业化用途，本卡只在discord社区类脑/旅程免费无偿发布，请不要成为它人的韭菜】**
**【3.本卡前端允许二改/借鉴/修改/学习，二改/直接使用需要询问，借鉴和摘抄结构需要发布时带上帖子链接以及@梦星标明来源 。之后有时间我也会写一篇mvu+同层游玩相关的教程，以及各种前端运用的思路和技巧，感谢大家支持和游玩，梦星再次拜谢】**




### 最新感谢名单（排名不分先后）
### ✋ 😭 🤚   赞美孑孓！
——梦星仅仅写了个开局前端的底模，之后都是孑孓进行相关开发，承担了90%以上的任务，非常感激孑孓！
### ✋ 😭 🤚  孑孓大人，我们敬爱你口牙！
### ✋ 😭 🤚  孑孓大人，我们敬爱你口牙！
### ✋ 😭 🤚  孑孓大人，我们敬爱你口牙！
——————
### ✋ 😭 🤚   赞美夜幕！
### ✋ 😭 🤚   赞美起物！
### ✋ 😭 🤚   赞美gydg！
超绝黑奴（不是

三位在审稿等方面帮助我良多，非常感激

以及夜幕帮忙整合世界书
辛苦了！


———————
✋ 😭 🤚   赞美白星！
虽然不知道赞美什么，算了留着吧
———————

最后欢迎大家加入来自梦星大人的归墟小团体，链接：[点击加入 Discord](https://discord.gg/epymFhrfHe)

    `;
    const contentEditor = `
### 开局编辑器使用教程
#### 1. 天赋背景编辑器
1.  进入开局选择发现没有天赋背景？点击重置编辑器会向归墟世界书写入系统天赋背景。
2.  默认没有系统天赋与背景，需要你自己创建；所有创建的天赋背景，默认关闭世界书，仅作为开局读取使用，不建议点击开启。

#### 2. 选择开局方式
1.  进入选择开局方式后，你只能看到你选中的预设下的系列天赋和背景以及无归属的通用天赋与背景。这避免了导入太多预设导致天赋堆成屎山的问题。
2.  选择预设后，会自动开启你所选择的预设所设置好的系列同名前缀【世界书】，并自动关闭其他预设相关的【世界书】，避免多个预设的世界书同时开启而忘记关闭，造成污染。

#### 3. 世界书编辑器
1.  可以自由创建和编辑所选择预设的系列世界书以及普通世界书的条目。
2.  可以分类筛选和查询天赋、背景、预设世界书。

#### 4. 预设编辑器
1.  在预设编辑器下的系列内容栏可以查看你所选择的预设下的所有专属天赋、背景、世界书扩展。
2.  可以通过编辑器勾选天赋为可选（开局自动勾选）或必选（开局强制勾选）。
3.  导出预设时，会抓取并打包所有与预设同系列、同作者前缀的世界书条目。
4.  所有设置了系列专属的天赋、背景，只有绑定了该系列的预设才能选择。没有设置系列归属的天赋、背景，不受此限制。

### 归墟创意工坊（首创思路）

### 目前归墟的世界书基础功能全开的情况下，已经压到10400token，且世界书结构清晰，划分明确，非常适合二创/使用编辑器换不同玩法

### 本编辑器提供了丰富的接口和可扩展性，可以大规模支持二创

### 您可以来归墟小团体，链接：[点击加入 Discord](https://discord.gg/epymFhrfHe)分享或者获取有趣的相关设定/或者超绝瑟瑟设定
### 同时优秀者也可以获取他人优秀归墟二创/新版本归墟游玩

### 希望大家能够积极参与分享！！
## 感谢您的参与，梦星感激不尽！



    `;
    const contentVersion = `
## ✨ 主要特性 (拼好卡v3.5)

归墟拼好卡 v3.5 是对1.8拼好卡旧版本的全面重构与升级，带来了架构、设计与核心系统的革新。

### 1. UI/UX 全面革新
- 界面重构: 桌面端将核心信息整合至主界面，移动端采用悬浮菜单并支持横屏，显著提升信息可视化与操作便捷性。
- 风格统一与自定义: 所有面板（背包、人物关系等）视觉风格统一，并新增“设置中心”，支持自定义背景、字体、分辨率，提供一键全屏、思维链折叠等功能。

### 2. 系统深化与智能管理
- 关系与背包升级: “人物关系”与“背包”面板功能重构，新增搜索、标签分组，并直观显示物品数量与价值。
- 自动化角色管理: 新增自动化角色提取功能，可将 NPC 信息快速写入世界书，并支持自定义提取规则。

### 3. 更生动的世界交互
- NPC 维度扩展: NPC 拥有独立的四维属性、天赋、灵根及装备系统，属性受装备影响，角色更加丰满。
- 新增交易与行动系统: 开放功能完善的交易系统，引入价格保护与 NPC 拒绝机制。新增行动选项系统，玩家可通过点击选项进行更具指导性的操作。

### 4. 底层架构优化
- 变量结构重构: 变量由数组重构为字典（键值对），彻底解决变量重复增值问题，并提高 LLM 对数值更新的准确性。
- 优化存档系统: 存档机制重构，游戏记录直接保存至世界书，避免因清理浏览器缓存导致存档丢失。

### 5. 世界书优化和新增

### 6. 大量Bug的修复

## ✨ 注意事项与常见问题排查

### 1. 运行环境与加载
- **网络要求:** 系统脚本通过 **JsDelivr** 加载，请务必保持良好的网络连接，否则可能导致功能异常。
- **加载失败:** 若首次开局卡在加载界面或UI渲染错乱，请尝试关闭酒馆页面后，再重新打开并读取。

### 2. 内容显示与交互
- **正文错乱:** 如正文中出现变量代码等无关内容，请使用编辑功能（小铅笔）检查，确保正文被 gametxt 标签完整包裹。
- **行动选项:** 若点击行动选项后没有反应，请同样检查并确保该选项被 action 标签正确包裹。

### 3. 存档管理与维护
- **开启新档:** 如需开启一个全新的游戏存档，您可以通过修改“读写序号”或在存档管理中心使用“**一键清除所有存档**”功能。
- **读档异常:** 读取存档后，若发现装备、物品等数据有遗漏，请尝试重新读取一遍该存档文件。

## 世界书插入位置参考

### 世界设定:
- 角色定义前1-18
- 角色定义后1-100
### 人物设定
- 神桥叙事:角色定义后100-300
- 非神桥叙事:角色定义后300-500
（大多数人物塞这里）
### cot:
- d0:100-200
### 其余设定:
- 参考世界书格式插入即可

    `;

    document.addEventListener('DOMContentLoaded', () => {
      const ABOUT_READ_KEY = 'guixu_has_read_about';
      const COUNTDOWN_SECONDS = 120;
      
      const VALID_CODES = [
        '孑孓大人太厉害了!!!!',
        '梦星大人太会摸鱼了!!!!',
        '看看注意事项吧！!!!!'
      ];

      const aboutBtn = document.getElementById('about-guixu-btn');
      const aboutModal = document.getElementById('about-guixu-modal');
      const readBtn = document.getElementById('about-read-btn');
      const countdownTimerEl = document.getElementById('about-countdown-timer');
      const tabContainer = aboutModal.querySelector('.about-tabs');
      const contentPanes = aboutModal.querySelectorAll('.about-tab-content');
      const redemptionContainer = document.getElementById('redemption-container');
      const redemptionInput = document.getElementById('redemption-code-input');
      const redemptionBtn = document.getElementById('redemption-code-btn');

      function normalizeString(str) {
        if (!str) return '';
        return str.replace(/！/g, '!');
      }

      function renderMarkdown(rawText) {
        if (typeof marked === 'undefined') {
          console.error('Markdown parser (marked.js) not loaded.');
          return rawText.replace(/\n/g, '<br>');
        }
        const renderer = new marked.Renderer();
        const defaultLinkRenderer = renderer.link;
        renderer.link = (href, title, text) => {
            const html = defaultLinkRenderer.call(renderer, href, title, text);
            return html.replace(/^<a /, '<a target="_blank" rel="noopener noreferrer" ');
        };
        return marked.parse(rawText, { renderer: renderer, gfm: true, breaks: true });
      }

      document.querySelector('[data-tab-content="credits"]').innerHTML = renderMarkdown(contentCredits);
      document.querySelector('[data-tab-content="editor-guide"]').innerHTML = renderMarkdown(contentEditor);
      document.querySelector('[data-tab-content="version-info"]').innerHTML = renderMarkdown(contentVersion);

      let countdownInterval;

      const bypassCountdown = () => {
        clearInterval(countdownInterval);
        countdownTimerEl.style.display = 'none';
        readBtn.disabled = false;
      };

      const startCountdown = () => {
        let timeLeft = COUNTDOWN_SECONDS;
        readBtn.disabled = true;
        readBtn.textContent = '已阅读';
        countdownTimerEl.style.display = 'block';
        countdownTimerEl.textContent = `请等待 ${timeLeft} 秒...`;

        countdownInterval = setInterval(() => {
          timeLeft--;
          countdownTimerEl.textContent = `请等待 ${timeLeft} 秒...`;
          if (timeLeft <= 0) {
            bypassCountdown();
          }
        }, 1000);
      };

      const showAboutModal = (isForced = false) => {
        aboutModal.style.display = 'flex';
        clearInterval(countdownInterval);
        redemptionContainer.classList.remove('visible');

        if (isForced) {
          startCountdown();
        } else {
          readBtn.disabled = false;
          readBtn.textContent = '关闭';
          countdownTimerEl.style.display = 'none';
        }
      };

      const hideAboutModal = () => {
        aboutModal.style.display = 'none';
        clearInterval(countdownInterval);
      };
      
      const handleScroll = (event) => {
        const el = event.target;
        if (el.scrollTop + el.clientHeight >= el.scrollHeight - 5) {
          redemptionContainer.classList.add('visible');
        }
      };

      contentPanes.forEach(pane => {
        pane.addEventListener('scroll', handleScroll);
      });

      // --- 兑换逻辑（无加密版） ---
      const handleRedemption = () => {
        const userInput = redemptionInput.value.trim();
        if (!userInput) return;

        const normalizedInput = normalizeString(userInput);
        
        // ★★★ 关键修改：直接比较标准化后的字符串 ★★★
        if (VALID_CODES.includes(normalizedInput)) {
          alert('兑换成功！已为您跳过等待。');
          bypassCountdown();
          redemptionContainer.classList.remove('visible');
        } else {
          alert('兑换码无效！');
          redemptionInput.value = '';
        }
      };

      redemptionBtn.addEventListener('click', handleRedemption);
      redemptionInput.addEventListener('keydown', (event) => {
        if (event.key === 'Enter') {
          handleRedemption();
        }
      });
      
      if (aboutBtn) { aboutBtn.addEventListener('click', () => showAboutModal(false)); }
      if (readBtn) { readBtn.addEventListener('click', () => { if (!readBtn.disabled) { if (readBtn.textContent === '已阅读') { localStorage.setItem(ABOUT_READ_KEY, 'true'); } hideAboutModal(); } }); }
      if (aboutModal) { aboutModal.addEventListener('click', (e) => { const isForced = readBtn.textContent === '已阅读' && readBtn.disabled; if (e.target === aboutModal && !isForced) { hideAboutModal(); } }); }
      if (tabContainer) { tabContainer.addEventListener('click', (e) => { const clickedTab = e.target.closest('.about-tab-btn'); if (!clickedTab) return; tabContainer.querySelectorAll('.about-tab-btn').forEach(btn => btn.classList.remove('active')); clickedTab.classList.add('active'); const tabName = clickedTab.dataset.tab; contentPanes.forEach(pane => { pane.classList.toggle('active', pane.dataset.tabContent === tabName); }); }); }
      if (localStorage.getItem(ABOUT_READ_KEY) !== 'true') { setTimeout(() => showAboutModal(true), 500); }
    });
  })();
</script>
</body>
</html>
```
